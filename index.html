<!DOCTYPE html><html><head><link href="META-INF/resources/webjars/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" /><link href="styles.css" rel="stylesheet" /><link rel="shortcut icon" type="image/png" href="favicon.png" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style>
.scalatex-site-Styles-headerLink{
  color: #777;
  opacity: 0.05;
  text-decoration: none;
}


.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink{
  color: #777;
  opacity: 0.5;
  text-decoration: none;
}
.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink:hover{
  opacity: 1.0;
}
.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink:active{
  opacity: 0.75;
}

.scalatex-site-Styles-content{
  color: #777;
  line-height: 1.6em;
  margin: 0 auto;
  margin-left: auto;
  margin-right: auto;
  max-width: 800px;
  padding: 0 1em;
  padding-bottom: 50px;
}
.scalatex-site-Styles-content *{
  position: relative;
}
.scalatex-site-Styles-content p{
  text-align: justify;
}
.scalatex-site-Styles-content a:link{
  color: #37a;
  text-decoration: none;
}
.scalatex-site-Styles-content a:visited{
  color: #949;
  text-decoration: none;
}
.scalatex-site-Styles-content a:hover{
  text-decoration: underline;
}
.scalatex-site-Styles-content a:active{
  color: #000;
  text-decoration: underline;
}
.scalatex-site-Styles-content code{
  color: #000;
}

/*Workaround for bug in highlight.js IDEA theme*/
span.hljs-tag, span.hljs-symbol{
    background: none;
}
    </style><title>uPickle 3.3.0</title><script src="scripts.js"></script></head><body><div>



<a href="https://github.com/lihaoyi/upickle-pprint"><img style="position: absolute;top: 0px;right: 0px;border: 0;" src="https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png" /></a>

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="uPickle3.3.0" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">uPickle 3.3.0<a class=" scalatex-site-Styles-headerLink" href="#uPickle3.3.0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div><div class=" scalatex-site-Styles-content">
  <div style="display: flex;align-items: center;flex-direction: column;">
    <div>
      <a href="https://gitter.im/lihaoyi/upickle"><img src="https://badges.gitter.im/Join%20Chat.svg" /></a>
      <span> </span>
      <a href="https://www.patreon.com/lihaoyi"><img src="https://img.shields.io/badge/patreon-sponsor-ff69b4.svg" /></a>
</div></div>
  <p>
    uPickle (pronounced micro-pickle) is a lightweight JSON and binary (MessagePack)
    serialization library for Scala. It's key features are:</p>
  <ul>
    <li>
      <a href="#GettingStarted">Simple to use</a>, with nice human-readable JSON output</li>
    <li>
      Very high <a href="#Performance">Performance</a>; faster than
      <a href="https://github.com/playframework/play-json">Play-Json</a>,
      <a href="https://github.com/circe/circe">Circe</a>, or
      <a href="https://github.com/argonaut-io/argonaut">Argonaut</a>
      by a large margin</li>
    <li>
      Simple &amp; easy to understand <a href="#uJson">JSON Processing API</a>,
      that should be instantly familiar to anyone whose processed JSON in
      Python, Ruby, or Javascript</li>
    <li>
      Flexible and easily <a href="#Customization">customizable</a></li>
    <li>
      Zero dependencies; can be included in any project without worrying about
      conflicts</li>
    <li>
      <a href="#ScalaJS">ScalaJS</a> support, allowing transfer of structured data
      between the JVM and Javascript</li>
    <li>
      Supports binary serialization via the MessagePack format, for even faster
      serialization/de-serialization and smaller payloads.
</li></ul>
  <p>
    This documentation is meant as a thorough reference to this library. For a hands-on
    introduction, take a look at the following blog post:
</p>
  <ul>
    <li>
      <a href="http://www.lihaoyi.com/post/HowtoworkwithJSONinScala.html">How to work with JSON in Scala</a>
</li></ul>
  <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="GettingStarted" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Getting Started<a class=" scalatex-site-Styles-headerLink" href="#GettingStarted" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <pre><code class="scala scalatex-site-Styles-highlightMe">&quot;com.lihaoyi&quot; %% &quot;upickle&quot; % &quot;3.2.0&quot; // SBT
ivy&quot;com.lihaoyi::upickle:3.3.0&quot; // Mill
</code></pre>
    <p>
      And then you can immediately start writing and reading common Scala
      objects to strings:
</p>
    <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import upickle.default._

write(1)                          ==&gt; &quot;1&quot;

write(Seq(1, 2, 3))               ==&gt; &quot;[1,2,3]&quot;

read[Seq[Int]](&quot;[1,2,3]&quot;)         ==&gt; List(1, 2, 3)

write((1, &quot;omg&quot;, true))           ==&gt; &quot;&quot;&quot;[1,&quot;omg&quot;,true]&quot;&quot;&quot;

read[(Int, String, Boolean)](&quot;&quot;&quot;[1,&quot;omg&quot;,true]&quot;&quot;&quot;) ==&gt; (1, &quot;omg&quot;, true)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L100-L111" target="_blank"><i class="fa fa-link "></i></a></pre>

    <p>
      Or to compact byte arrays, using the <a href="https://msgpack.org/index.html">MessagePack</a>
      format:
</p>
    <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import upickle.default._

writeBinary(1)                          ==&gt; Array(1)

writeBinary(Seq(1, 2, 3))               ==&gt; Array(0x93.toByte, 1, 2, 3)

readBinary[Seq[Int]](Array[Byte](0x93.toByte, 1, 2, 3))  ==&gt; List(1, 2, 3)

val serializedTuple = Array[Byte](0x93.toByte, 1, 0xa3.toByte, 111, 109, 103, 0xc3.toByte)

writeBinary((1, &quot;omg&quot;, true))           ==&gt; serializedTuple

readBinary[(Int, String, Boolean)](serializedTuple) ==&gt; (1, &quot;omg&quot;, true)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L113-L126" target="_blank"><i class="fa fa-link "></i></a></pre>

    <h1 id="ScalaJS" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#ScalaJS" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>ScalaJS</h1>
      <p>
        For ScalaJS applications, use this dependencies instead:</p>
      <pre><code class="scala scalatex-site-Styles-highlightMe">&quot;com.lihaoyi&quot; %%% &quot;upickle&quot; % &quot;3.3.0&quot; // SBT
ivy&quot;com.lihaoyi::upickle::3.3.0&quot; // Mill
</code></pre>
    <h1 id="ScalaVersions" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#ScalaVersions" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Scala Versions</h1>
      <p>

        uPickle supports Scala 2.12, 2.13 and 3.1+
</p>
  <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Basics" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Basics<a class=" scalatex-site-Styles-headerLink" href="#Basics" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <h1 id="Builtins" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Builtins" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Builtins</h1>
      <p>
        This is a non-comprehensive list of what the most commonly-used types
         pickle to using uPickle. To begin, let's import upickle
</p>
      <pre><code class="scala scalatex-site-Styles-highlightMe">import upickle.default._
</code></pre>
      <h2 id="Primitives" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Primitives" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Primitives</h2>
        <p>
          Booleans are serialized as JSON booleans
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">write(true: Boolean)              ==&gt; &quot;true&quot;
write(false: Boolean)             ==&gt; &quot;false&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L130-L132" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
          Numbers are serialized as JSON numbers
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">write(12: Int)                    ==&gt; &quot;12&quot;
write(12: Short)                  ==&gt; &quot;12&quot;
write(12: Byte)                   ==&gt; &quot;12&quot;
write(Int.MaxValue)               ==&gt; &quot;2147483647&quot;
write(Int.MinValue)               ==&gt; &quot;-2147483648&quot;
write(12.5f: Float)               ==&gt; &quot;12.5&quot;
write(12.5: Double)               ==&gt; &quot;12.5&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L134-L141" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
          Except for <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Long</code>s, which too large for Javascript. These are
          serialized as JSON Strings, keeping the interchange format compatible
           with the browser's own JSON parser, which provides the best
            performance in Scala.js
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">write(12: Long)                   ==&gt; &quot;12&quot;
write(4000000000000L: Long)       ==&gt; &quot;4000000000000&quot;
// large longs are written as strings, to avoid floating point rounding
write(9223372036854775807L: Long) ==&gt; &quot;\&quot;9223372036854775807\&quot;&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L143-L147" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
          Special values of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Double</code>s and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Float</code>s are also
          serialized as Strings
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">write(1.0/0: Double)              ==&gt; &quot;\&quot;Infinity\&quot;&quot;
write(Float.PositiveInfinity)     ==&gt; &quot;\&quot;Infinity\&quot;&quot;
write(Float.NegativeInfinity)     ==&gt; &quot;\&quot;-Infinity\&quot;&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L149-L152" target="_blank"><i class="fa fa-link "></i></a></pre>



        <p>
          Both <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Char</code>s and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">String</code>s are serialized as Strings
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">write('o')                        ==&gt; &quot;\&quot;o\&quot;&quot;
write(&quot;omg&quot;)                      ==&gt; &quot;\&quot;omg\&quot;&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L154-L156" target="_blank"><i class="fa fa-link "></i></a></pre>
      <h2 id="Collections" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Collections" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Collections</h2>
        <p>
          <code>Array</code>s and most immutable collections are serialized as JSON lists
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">write(Array.empty[Int])           ==&gt; &quot;[]&quot;
write(Array(1, 2, 3))             ==&gt; &quot;[1,2,3]&quot;

// You can pass in an `indent` parameter to format it nicely
write(Array.empty[Int], indent = 4)  ==&gt; &quot;[]&quot;
write(Array(1, 2, 3), indent = 4)  ==&gt;
  &quot;&quot;&quot;[
    |    1,
    |    2,
    |    3
    |]&quot;&quot;&quot;.stripMargin

write(Seq(1, 2, 3))               ==&gt; &quot;[1,2,3]&quot;
write(Vector(1, 2, 3))            ==&gt; &quot;[1,2,3]&quot;
write(List(1, 2, 3))              ==&gt; &quot;[1,2,3]&quot;
import collection.immutable.SortedSet
write(SortedSet(1, 2, 3))         ==&gt; &quot;[1,2,3]&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L158-L175" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
          <code>Option</code>s are serialized as JSON lists with 0 or 1 element
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">write(Some(1))                    ==&gt; &quot;[1]&quot;
write(None)                       ==&gt; &quot;[]&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L194-L196" target="_blank"><i class="fa fa-link "></i></a></pre>


        <p>
          Tuples of all sizes (1-22) are serialized as heterogenous JSON lists
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">write((1, &quot;omg&quot;))                 ==&gt; &quot;&quot;&quot;[1,&quot;omg&quot;]&quot;&quot;&quot;
write((1, &quot;omg&quot;, true))           ==&gt; &quot;&quot;&quot;[1,&quot;omg&quot;,true]&quot;&quot;&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L198-L200" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
          <code>Map</code>s with primitive keys are serialized into JSON dictionaries,
          while <code>Map</code> with complex keys are serialized into lists of
          2-element tuples
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">write(Map(1 -&gt; 2, 3 -&gt; 4))         ==&gt; &quot;&quot;&quot;{&quot;1&quot;:2,&quot;3&quot;:4}&quot;&quot;&quot;
write(Map(&quot;hello&quot; -&gt; &quot;world&quot;))     ==&gt; &quot;&quot;&quot;{&quot;hello&quot;:&quot;world&quot;}&quot;&quot;&quot;
write(Map(Seq(1, 2) -&gt; Seq(3, 4))) ==&gt; &quot;&quot;&quot;[[[1,2],[3,4]]]&quot;&quot;&quot;
write(Map.empty[Int, Int])         ==&gt; &quot;&quot;&quot;{}&quot;&quot;&quot;
write(Map(Seq.empty[Int] -&gt; Seq.empty[Int])) ==&gt; &quot;&quot;&quot;[[[],[]]]&quot;&quot;&quot;

write(Map(Seq.empty[Int] -&gt; Seq.empty[Int]), indent = 4) ==&gt;
&quot;&quot;&quot;[
  |    [
  |        [],
  |        []
  |    ]
  |]&quot;&quot;&quot;.stripMargin

write(Map.empty[Int, Int], indent = 4) ==&gt; &quot;&quot;&quot;{}&quot;&quot;&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L177-L192" target="_blank"><i class="fa fa-link "></i></a></pre>

      <h2 id="CaseClasses" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#CaseClasses" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Case Classes</h2>
        <p>
          Case classes of sizes 1-64 are serialized as JSON dictionaries with the
          keys being the names of each field.
          To begin with, you need to define a serializer in the Case Class's
          companion object:
</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">import upickle.default.{ReadWriter =&gt; RW, macroRW}
</code></pre>
        <p>
          After that, you can begin serializing that case class.
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">case class Thing(myFieldA: Int, myFieldB: String)
object Thing{
  implicit val rw: RW[Thing] = macroRW
}
case class Big(i: Int, b: Boolean, str: String, c: Char, t: Thing)
object Big{
  implicit val rw: RW[Big] = macroRW
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L12-L20" target="_blank"><i class="fa fa-link "></i></a></pre>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import upickle._
write(Thing(1, &quot;gg&quot;))             ==&gt; &quot;&quot;&quot;{&quot;myFieldA&quot;:1,&quot;myFieldB&quot;:&quot;gg&quot;}&quot;&quot;&quot;
read[Thing](&quot;&quot;&quot;{&quot;myFieldA&quot;:1,&quot;myFieldB&quot;:&quot;gg&quot;}&quot;&quot;&quot;) ==&gt; Thing(1, &quot;gg&quot;)
write(Big(1, true, &quot;lol&quot;, 'Z', Thing(7, &quot;&quot;))) ==&gt;
  &quot;&quot;&quot;{&quot;i&quot;:1,&quot;b&quot;:true,&quot;str&quot;:&quot;lol&quot;,&quot;c&quot;:&quot;Z&quot;,&quot;t&quot;:{&quot;myFieldA&quot;:7,&quot;myFieldB&quot;:&quot;&quot;}}&quot;&quot;&quot;

write(Big(1, true, &quot;lol&quot;, 'Z', Thing(7, &quot;&quot;)), indent = 4) ==&gt;
  &quot;&quot;&quot;{
    |    &quot;i&quot;: 1,
    |    &quot;b&quot;: true,
    |    &quot;str&quot;: &quot;lol&quot;,
    |    &quot;c&quot;: &quot;Z&quot;,
    |    &quot;t&quot;: {
    |        &quot;myFieldA&quot;: 7,
    |        &quot;myFieldB&quot;: &quot;&quot;
    |    }
    |}&quot;&quot;&quot;.stripMargin

write(Big(1, true, &quot;lol&quot;, 'Z', Thing(7, &quot;&quot;)), indent = 4, sortKeys = true) ==&gt;
  &quot;&quot;&quot;{
    |    &quot;b&quot;: true,
    |    &quot;c&quot;: &quot;Z&quot;,
    |    &quot;i&quot;: 1,
    |    &quot;str&quot;: &quot;lol&quot;,
    |    &quot;t&quot;: {
    |        &quot;myFieldA&quot;: 7,
    |        &quot;myFieldB&quot;: &quot;&quot;
    |    }
    |}&quot;&quot;&quot;.stripMargin</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L203-L232" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
          Sealed hierarchies are serialized as tagged values, the serialized
          object tagged with the full name of the instance's class:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">sealed trait IntOrTuple
object IntOrTuple{
  implicit val rw: RW[IntOrTuple] = RW.merge(IntThing.rw, TupleThing.rw)
}
case class IntThing(i: Int) extends IntOrTuple
object IntThing{
  implicit val rw: RW[IntThing] = macroRW
}
case class TupleThing(name: String, t: (Int, Int)) extends IntOrTuple
object TupleThing{
  implicit val rw: RW[TupleThing] = macroRW
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L22-L34" target="_blank"><i class="fa fa-link "></i></a></pre>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">write(IntThing(1)) ==&gt; &quot;&quot;&quot;{&quot;$type&quot;:&quot;upickle.example.Sealed.IntThing&quot;,&quot;i&quot;:1}&quot;&quot;&quot;

write(TupleThing(&quot;naeem&quot;, (1, 2))) ==&gt;
  &quot;&quot;&quot;{&quot;$type&quot;:&quot;upickle.example.Sealed.TupleThing&quot;,&quot;name&quot;:&quot;naeem&quot;,&quot;t&quot;:[1,2]}&quot;&quot;&quot;

// You can read tagged value without knowing its
// type in advance, just use type of the sealed trait
read[IntOrTuple](&quot;&quot;&quot;{&quot;$type&quot;:&quot;upickle.example.Sealed.IntThing&quot;,&quot;i&quot;:1}&quot;&quot;&quot;) ==&gt; IntThing(1)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L236-L245" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
          Serializability is recursive; you can serialize a type only if all
          its members are serializable. That means that collections, tuples and
          case-classes made only of serializable members are themselves serializable
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">case class Foo(i: Int)
object Foo{
  implicit val rw: RW[Foo] = macroRW
}
case class Bar(name: String, foos: Seq[Foo])
object Bar{
  implicit val rw: RW[Bar] = macroRW
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L36-L44" target="_blank"><i class="fa fa-link "></i></a></pre>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">write((((1, 2), (3, 4)), ((5, 6), (7, 8)))) ==&gt;
  &quot;&quot;&quot;[[[1,2],[3,4]],[[5,6],[7,8]]]&quot;&quot;&quot;

write(Seq(Thing(1, &quot;g&quot;), Thing(2, &quot;k&quot;))) ==&gt;
  &quot;&quot;&quot;[{&quot;myFieldA&quot;:1,&quot;myFieldB&quot;:&quot;g&quot;},{&quot;myFieldA&quot;:2,&quot;myFieldB&quot;:&quot;k&quot;}]&quot;&quot;&quot;

write(Bar(&quot;bearrr&quot;, Seq(Foo(1), Foo(2), Foo(3)))) ==&gt;
  &quot;&quot;&quot;{&quot;name&quot;:&quot;bearrr&quot;,&quot;foos&quot;:[{&quot;i&quot;:1},{&quot;i&quot;:2},{&quot;i&quot;:3}]}&quot;&quot;&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L247-L255" target="_blank"><i class="fa fa-link "></i></a></pre>
      <h2 id="Scala3Deriving" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Scala3Deriving" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Scala 3 Deriving</h2>
        <p>
          In Scala 3, you can use the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">derives</code> keyword on standalone
          <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">case class</code>es, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">sealed trait</code> hierarchies, and
          <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">enum</code>s:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">case class Dog(name: String, age: Int) derives ReadWriter</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src-3/upickle/DerivationTests.scala#L8-L9" target="_blank"><i class="fa fa-link "></i></a></pre>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">upickle.default.write(Dog(&quot;Ball&quot;, 2)) ==&gt; &quot;&quot;&quot;{&quot;name&quot;:&quot;Ball&quot;,&quot;age&quot;:2}&quot;&quot;&quot;
upickle.default.read[Dog](&quot;&quot;&quot;{&quot;name&quot;:&quot;Ball&quot;,&quot;age&quot;:2}&quot;&quot;&quot;) ==&gt; Dog(&quot;Ball&quot;, 2)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src-3/upickle/DerivationTests.scala#L56-L58" target="_blank"><i class="fa fa-link "></i></a></pre>

        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">sealed trait Animal derives ReadWriter
case class Person(name: String, address: String, age: Int = 20) extends Animal
case class Cat(name: String, owner: Person) extends Animal
case object Cthulu extends Animal</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src-3/upickle/DerivationTests.scala#L10-L14" target="_blank"><i class="fa fa-link "></i></a></pre>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">upickle.default.write(Person(&quot;Peter&quot;, &quot;Ave 10&quot;)) ==&gt;
  &quot;&quot;&quot;{&quot;$type&quot;:&quot;upickle.Person&quot;,&quot;name&quot;:&quot;Peter&quot;,&quot;address&quot;:&quot;Ave 10&quot;}&quot;&quot;&quot;

upickle.default.read[Animal](&quot;&quot;&quot;{&quot;$type&quot;:&quot;upickle.Person&quot;,&quot;name&quot;:&quot;Peter&quot;,&quot;address&quot;:&quot;Ave 10&quot;}&quot;&quot;&quot;) ==&gt;
  Person(&quot;Peter&quot;, &quot;Ave 10&quot;)

upickle.default.write(Cthulu) ==&gt; &quot;\&quot;upickle.Cthulu\&quot;&quot;
upickle.default.read[Animal](&quot;\&quot;upickle.Cthulu\&quot;&quot;) ==&gt; Cthulu</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src-3/upickle/DerivationTests.scala#L60-L68" target="_blank"><i class="fa fa-link "></i></a></pre>

        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">enum SimpleEnum derives ReadWriter:
  case A, B</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src-3/upickle/EnumTests.scala#L10-L12" target="_blank"><i class="fa fa-link "></i></a></pre>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">upickle.default.write(SimpleEnum.A) ==&gt; &quot;\&quot;A\&quot;&quot;
upickle.default.read[SimpleEnum](&quot;\&quot;A\&quot;&quot;) ==&gt; SimpleEnum.A</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src-3/upickle/EnumTests.scala#L42-L44" target="_blank"><i class="fa fa-link "></i></a></pre>

        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">enum ColorEnum(val rgb: Int) derives ReadWriter:
  case Red extends ColorEnum(0xFF0000)
  case Green extends ColorEnum(0x00FF00)
  case Blue extends ColorEnum(0x0000FF)
  case Mix(mix: Int) extends ColorEnum(mix)
  case Unknown(mix: Int) extends ColorEnum(0x000000)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src-3/upickle/EnumTests.scala#L15-L21" target="_blank"><i class="fa fa-link "></i></a></pre>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">Enclosing(&quot;test&quot;, SimpleEnum.A, Some(SimpleEnum.B)),
&quot;&quot;&quot;{&quot;str&quot;:&quot;test&quot;,&quot;simple1&quot;:&quot;A&quot;,&quot;simple2&quot;:[&quot;B&quot;]}&quot;&quot;&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src-3/upickle/EnumTests.scala#L66-L68" target="_blank"><i class="fa fa-link "></i></a></pre>
      <p>
        Note that you only need to put the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">derives</code> keyword on the
        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">enum</code>s or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">sealed trait</code>s, and not on all the
        individual <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">case class</code>es or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">case object</code>s.
</p>
      <p>
        Also, note that for <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">enum</code>s, the short un-qualified name is used
        for the type key, rather than the fully qualified name with package path.
        This is because unlike <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">sealed trait</code>s, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">enum</code>s enforce
        that every case is in the same flat namespace, and thus the short name is
        enough to dis-ambiguate them. This behavior can be overriden with the
        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">@key(&quot;...&quot;)</code> annotation in both cases, if a different type key
        is desired.
</p>
    <h1 id="Read/WritingOtherThings" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Read/WritingOtherThings" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Read/Writing Other Things</h1>

      <p>
        Apart from reading &amp; writing <code>java.lang.String</code>s, allows you to easily
        read from alternate sources such as <code>CharSequence</code>s, <code>Array[Byte]</code>s,
        <code>java.io.File</code>s and <code>java.nio.file.Path</code>s:
</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import upickle.default._
val original = &quot;&quot;&quot;{&quot;myFieldA&quot;:1,&quot;myFieldB&quot;:&quot;gg&quot;}&quot;&quot;&quot;
read[Thing](original) ==&gt; Thing(1, &quot;gg&quot;)
read[Thing](original: CharSequence) ==&gt; Thing(1, &quot;gg&quot;)
read[Thing](original.getBytes) ==&gt; Thing(1, &quot;gg&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L275-L280" target="_blank"><i class="fa fa-link "></i></a></pre>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import upickle.default._
val original = &quot;&quot;&quot;{&quot;myFieldA&quot;:1,&quot;myFieldB&quot;:&quot;gg&quot;}&quot;&quot;&quot;

import java.nio.file.Files
val f = Files.createTempFile(&quot;&quot;, &quot;&quot;)
Files.write(f, original.getBytes)

read[Thing](f) ==&gt; Thing(1, &quot;gg&quot;)
read[Thing](f.toFile) ==&gt; Thing(1, &quot;gg&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src-jvm-2/upickle/example/JvmExampleTests.scala#L16-L25" target="_blank"><i class="fa fa-link "></i></a></pre>

      <p>
        Reading from large files is automatically streamed so you do not read the
        entire file into memory. You can use <code>writeTo</code> to serialize your
        data to an arbitrary <code>java.io.Writer</code>/<code>java.io.OutputStream</code>:
        this can be streamed directly to files or over the network without having
        to accumulate the serialized JSON in memory.</p>
    <h1 id="Nulls" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Nulls" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Nulls</h1>
      <p></p>
      
        Nulls serialize into JSON nulls, as you would expect
      
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">write(Bar(null, Seq(Foo(1), null, Foo(3)))) ==&gt;
  &quot;&quot;&quot;{&quot;name&quot;:null,&quot;foos&quot;:[{&quot;i&quot;:1},null,{&quot;i&quot;:3}]}&quot;&quot;&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L257-L259" target="_blank"><i class="fa fa-link "></i></a></pre>
      
      <p>
        uPickle only throws exceptions on unpickling; if a pickler is
        properly defined, serializing a data structure to a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">String</code>
        should never throw an exception.
      </p>
      <p>
        All these examples can be similarly serialized to MessagePack-formatted
        binaries, in the same way: JSON booleans become MessagePack booleans,
        lists become MessagePack lists, and so on. Reading and writing
        MessagePack binary data is typically significantly faster than reading
        and writing JSON, and the serialized data is also significantly smaller.
</p>
    <h1 id="Defaults" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Defaults" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Defaults</h1>

      <p>
        If a field is missing upon deserialization, uPickle uses the default
        value if one exists
</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">read[FooDefault](&quot;{}&quot;)                ==&gt; FooDefault(10, &quot;lol&quot;)
read[FooDefault](&quot;&quot;&quot;{&quot;i&quot;: 123}&quot;&quot;&quot;)    ==&gt; FooDefault(123,&quot;lol&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L264-L266" target="_blank"><i class="fa fa-link "></i></a></pre>

      <p>

        If a field at serialization time has the same value as the default,
         uPickle leaves it out of the serialized blob
</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">write(FooDefault(i = 11, s = &quot;lol&quot;))  ==&gt; &quot;&quot;&quot;{&quot;i&quot;:11}&quot;&quot;&quot;
write(FooDefault(i = 10, s = &quot;lol&quot;))  ==&gt; &quot;&quot;&quot;{}&quot;&quot;&quot;
write(FooDefault())                   ==&gt; &quot;&quot;&quot;{}&quot;&quot;&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L268-L271" target="_blank"><i class="fa fa-link "></i></a></pre>

      <p>

        This allows you to make schema changes gradually, assuming you have
        already pickled some data and want to add new fields to the case classes
        you pickled. Simply give the new fields a default value (e.g.
        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;&quot;</code> for Strings, or wrap it in an <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Option[T]</code> and
        make the default <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">None</code>) and uPickle will happily read the
        old data, filling in the missing field using the default value.
</p>
    <h1 id="SupportedTypes" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#SupportedTypes" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Supported Types</h1>
      <p>
        Out of the box, uPickle supports writing and reading the following types:</p>
      <ul>
        <li>
          <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Boolean</code>, <code>Byte</code>, <code>Char</code>, <code>Short</code>,
          <code>Int</code>, <code>Long</code>, <code>Float</code>, <code>Double</code></li>
        <li>
          <code>Tuple</code>s from 1 to 22</li>
        <li>
          Immutable <code>Seq</code>, <code>List</code>, <code>Vector</code>, <code>Set</code>,
          <code>SortedSet</code>, <code>Option</code>, <code>Array</code>, <code>Map</code>s, and all
          other collections with a reasonable <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CanBuildFrom</code> implementation</li>
        <li>
          <code>Duration</code>, <code>Either</code></li>
        <li>
          Stand-alone <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">case class</code>es and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">case object</code>s, and
           their generic equivalents,</li>
        <li>
          Non-generic <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">case class</code>es and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">case object</code>s that
          are part of a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">sealed trait</code> or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">sealed class</code> hierarchy</li>
        <li>
          <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">sealed trait</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">sealed class</code>es themselves,
           assuming that all subclasses are picklable</li>
        <li>
          <code>UUID</code>s</li>
        <li>
          <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">null</code></li></ul>
      <p>
        Readability/writability is recursive: a container such as a <code>Tuple</code>
        or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">case class</code> is only readable if all its contents are
         readable, and only writable if all its contents are writable. That means
          that you cannot serialize a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">List[Any]</code>, since uPickle doesn't
           provide a generic way of serializing <code>Any</code>. Case classes are only
           serializable up to 64 fields.
</p>
      <p>
        Case classes are serialized using the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">apply</code> and
        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">unapply</code> methods on their companion objects. This means that
        you can make your own classes serializable by giving them companions
         <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">apply</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">unapply</code>. <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">sealed</code> hierarchies
         are serialized as tagged unions: whatever the serialization of the
         actual object, together with the fully-qualified name of its class, so
          the correct class in the sealed hierarchy can be reconstituted later.
</p>
      <p>
        That concludes the list of supported types. Anything else is not supported
        by default, but you can add support using <a href="#CustomPicklers">Custom Picklers</a>
</p>
    <h1 id="CommonOperations" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#CommonOperations" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Common Operations</h1>
      <p>
        The following common operations are available on any uPickle module,
        e.g. <code>upickle.default</code> or <code>upickle.legacy</code>:
</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">trait Api
    extends upickle.core.Types
    with implicits.Readers
    with implicits.Writers
    with implicits.CaseClassReadWriters
    with WebJson
    with JsReadWriters
    with MsgReadWriters
    with Annotator{

  private def maybeSortKeysTransform[T: Writer, V](t: T,
                                                   sortKeys: Boolean,
                                                   f: Visitor[_, V]): V = {
    BufferedValue.maybeSortKeysTransform(implicitly[Writer[T]], t, sortKeys, f)
  }
  /**
    * Reads the given MessagePack input into a Scala value
    */
  def readBinary[T: Reader](s: upack.Readable, trace: Boolean = false): T = {
    TraceVisitor.withTrace(trace, reader[T])(s.transform(_))
  }

  /**
    * Reads the given JSON input into a Scala value
    */
  def read[T: Reader](s: ujson.Readable, trace: Boolean = false): T = {
    TraceVisitor.withTrace(trace, reader[T])(s.transform(_))
  }

  def reader[T: Reader] = implicitly[Reader[T]]

  /**
    * Write the given Scala value as a JSON string
    */
  def write[T: Writer](t: T,
                       indent: Int = -1,
                       escapeUnicode: Boolean = false,
                       sortKeys: Boolean = false): String = {
    maybeSortKeysTransform(t, sortKeys, ujson.StringRenderer(indent, escapeUnicode)).toString
  }

  // @deprecated(&quot;Binary Compatibility Stub&quot;, &quot;upickle after 3.1.4&quot;)
  def write[T: Writer](t: T,
                       indent: Int,
                       escapeUnicode: Boolean): String = {
    write(t, indent, escapeUnicode, sortKeys = false)
  }

  /**
    * Write the given Scala value as a MessagePack binary
    */
  def writeBinary[T: Writer](t: T,
                             sortKeys: Boolean = false): Array[Byte] = {
    maybeSortKeysTransform(t, sortKeys, new upack.MsgPackWriter(new ByteArrayOutputStream())).toByteArray
  }

  // @deprecated(&quot;Binary Compatibility Stub&quot;, &quot;upickle after 3.1.4&quot;)
  def writeBinary[T: Writer](t: T): Array[Byte] = writeBinary(t, sortKeys = false)

  /**
    * Write the given Scala value as a JSON struct
    */
  def writeJs[T: Writer](t: T): ujson.Value = transform(t).to[ujson.Value]

  /**
    * Write the given Scala value as a MessagePack struct
    */
  def writeMsg[T: Writer](t: T): upack.Msg = transform(t).to[upack.Msg]

  /**
    * Write the given Scala value as a JSON string to the given Writer
    */
  def writeTo[T: Writer](t: T,
                         out: java.io.Writer,
                         indent: Int = -1,
                         escapeUnicode: Boolean = false,
                         sortKeys: Boolean = false): Unit = {
    maybeSortKeysTransform(t, sortKeys, new ujson.Renderer(out, indent = indent, escapeUnicode))
  }


  // @deprecated(&quot;Binary Compatibility Stub&quot;, &quot;upickle after 3.1.4&quot;)
  def writeTo[T: Writer](t: T,
                         out: java.io.Writer,
                         indent: Int,
                         escapeUnicode: Boolean): Unit = writeTo(t, out, indent, escapeUnicode, sortKeys = false)

  def writeToOutputStream[T: Writer](t: T,
                                     out: java.io.OutputStream,
                                     indent: Int = -1,
                                     escapeUnicode: Boolean = false,
                                     sortKeys: Boolean = false): Unit = {
    maybeSortKeysTransform(t, sortKeys, new ujson.BaseByteRenderer(out, indent = indent, escapeUnicode))
  }

  // @deprecated(&quot;Binary Compatibility Stub&quot;, &quot;upickle after 3.1.4&quot;)
  def writeToOutputStream[T: Writer](t: T,
                                     out: java.io.OutputStream,
                                     indent: Int,
                                     escapeUnicode: Boolean): Unit = {
    writeToOutputStream(t, out, indent, escapeUnicode, sortKeys = false)
  }

  def writeToByteArray[T: Writer](t: T,
                                  indent: Int = -1,
                                  escapeUnicode: Boolean = false,
                                  sortKeys: Boolean = false): Array[Byte] = {
    val out = new java.io.ByteArrayOutputStream()
    writeToOutputStream(t, out, indent, escapeUnicode, sortKeys)
    out.toByteArray
  }

  // @deprecated(&quot;Binary Compatibility Stub&quot;, &quot;upickle after 3.1.4&quot;)
  def writeToByteArray[T: Writer](t: T,
                                  indent: Int,
                                  escapeUnicode: Boolean): Array[Byte] = {
    writeToByteArray[T](t, indent, escapeUnicode, sortKeys = false)
  }
  /**
    * Write the given Scala value as a JSON string via a `geny.Writable`
    */
  def stream[T: Writer](t: T,
                        indent: Int = -1,
                        escapeUnicode: Boolean = false,
                        sortKeys: Boolean = false): geny.Writable = new geny.Writable{
    override def httpContentType = Some(&quot;application/json&quot;)
    def writeBytesTo(out: java.io.OutputStream) = {
      maybeSortKeysTransform(t, sortKeys, new ujson.BaseByteRenderer(out, indent = indent, escapeUnicode))
    }
  }

  // @deprecated(&quot;Binary Compatibility Stub&quot;, &quot;upickle after 3.1.4&quot;)
  def stream[T: Writer](t: T,
                        indent: Int,
                        escapeUnicode: Boolean): geny.Writable = {
    stream(t, indent, escapeUnicode, sortKeys = false)
  }
  /**
    * Write the given Scala value as a MessagePack binary to the given OutputStream
    */
  def writeBinaryTo[T: Writer](t: T,
                               out: java.io.OutputStream,
                               sortKeys: Boolean = false): Unit = {
    streamBinary[T](t, sortKeys = sortKeys).writeBytesTo(out)
  }

  // @deprecated(&quot;Binary Compatibility Stub&quot;, &quot;upickle after 3.1.4&quot;)
  def writeBinaryTo[T: Writer](t: T,
                               out: java.io.OutputStream): Unit = {
    writeBinaryTo(t, out, sortKeys = false)
  }

  def writeBinaryToByteArray[T: Writer](t: T,
                                        sortKeys: Boolean = false): Array[Byte] = {
    val out = new java.io.ByteArrayOutputStream()
    streamBinary[T](t, sortKeys = sortKeys).writeBytesTo(out)
    out.toByteArray
  }

  // @deprecated(&quot;Binary Compatibility Stub&quot;, &quot;upickle after 3.1.4&quot;)
  def writeBinaryToByteArray[T: Writer](t: T): Array[Byte] = {
    writeBinaryToByteArray(t, sortKeys = false)
  }
  /**
    * Write the given Scala value as a MessagePack binary via a `geny.Writable`
    */
  def streamBinary[T: Writer](t: T, sortKeys: Boolean = false): geny.Writable = new geny.Writable{
    override def httpContentType = Some(&quot;application/octet-stream&quot;)
    def writeBytesTo(out: java.io.OutputStream) = maybeSortKeysTransform(t, sortKeys, new upack.MsgPackWriter(out))
  }

  // @deprecated(&quot;Binary Compatibility Stub&quot;, &quot;upickle after 3.1.4&quot;)
  def streamBinary[T: Writer](t: T): geny.Writable = {
    streamBinary(t, sortKeys = false)
  }

  def writer[T: Writer] = implicitly[Writer[T]]

  def readwriter[T: ReadWriter] = implicitly[ReadWriter[T]]

  case class transform[T: Writer](t: T) extends upack.Readable with ujson.Readable {
    def transform[V](f: Visitor[_, V]): V = writer[T].transform(t, f)
    def to[V](f: Visitor[_, V]): V = transform(f)
    def to[V](implicit f: Reader[V]): V = transform(f)
  }


  /**
   * Mark a `ReadWriter[T]` as something that can be used as a key in a JSON
   * dictionary, such that `Map[T, V]` serializes to `{&quot;a&quot;: &quot;b&quot;, &quot;c&quot;: &quot;d&quot;}`
   * rather than `[[&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;]]`
   */
  def stringKeyRW[T](readwriter: ReadWriter[T]): ReadWriter[T] = {
    new ReadWriter.Delegate[T](readwriter) {
      override def isJsonDictKey = true
      def write0[R](out: Visitor[_, R], v: T): R = readwriter.write0(out, v)
    }
  }

  /**
   * Mark a `Writer[T]` as something that can be used as a key in a JSON
   * dictionary, such that `Map[T, V]` serializes to `{&quot;a&quot;: &quot;b&quot;, &quot;c&quot;: &quot;d&quot;}`
   * rather than `[[&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;]]`
   */
  def stringKeyW[T](readwriter: Writer[T]): Writer[T] = new Writer[T]{
    override def isJsonDictKey = true
    def write0[R](out: Visitor[_, R], v: T): R = readwriter.write0(out, v)
  }

  /**
   * Configure whether you want upickle to skip unknown keys during de-serialization
   * of `case class`es. Can be overriden for the entire serializer via `override def`, and
   * further overriden for individual `case class`es via the annotation
   * `@upickle.implicits.allowUnknownKeys(b: Boolean)`
   */
  override def allowUnknownKeys: Boolean = true</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/src/upickle/Api.scala#L15-L231" target="_blank"><i class="fa fa-link "></i></a></pre>

  <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Customization" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Customization<a class=" scalatex-site-Styles-headerLink" href="#Customization" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <h1 id="CustomPicklers" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#CustomPicklers" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Custom Picklers</h1>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import upickle.default._
case class Wrap(i: Int)
implicit val fooReadWrite: ReadWriter[Wrap] =
  readwriter[Int].bimap[Wrap](_.i, Wrap(_))

write(Seq(Wrap(1), Wrap(10), Wrap(100))) ==&gt; &quot;[1,10,100]&quot;
read[Seq[Wrap]](&quot;[1,10,100]&quot;) ==&gt; Seq(Wrap(1), Wrap(10), Wrap(100))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L283-L290" target="_blank"><i class="fa fa-link "></i></a></pre>

      <p>
        You can use the <code>readwriter[T].bimap[V]</code> function to create a pickler
        that reads/writes a type <code>V</code>, using the pickler for type <code>T</code>,
        by providing a conversion function between them.
</p>
      <p>
        The type you are <code>.bimap</code>ing to doesn't need to be a case class,
        or be pickleable in any way, as long as the type you are
        <code>.bimap</code>ing from is pickleable. The following example demonstrates
        using <code>.bimap</code> to define a serializer for non-case Scala class
</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">class CustomThing2(val i: Int, val s: String)
object CustomThing2 {
  implicit val rw: RW[CustomThing2] = upickle.default.readwriter[String].bimap[CustomThing2](
    x =&gt; s&quot;${x.i} ${x.s}&quot;,
    str =&gt; {
      val Array(i, s) = str.split(&quot; &quot;, 2)
      new CustomThing2(i.toInt, s)
    }
  )
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L69-L79" target="_blank"><i class="fa fa-link "></i></a></pre>

      <p>
        Note that when writing custom picklers, it is entirely up to you to get
        it right, e.g. making sure that an object that gets round-trip
        pickled/unpickled comes out the same as when it started.
</p>
      <p>
        Lastly, if you want more control over exactly how something is serialized,
        you can use <code>readwriter[Js.Value].bimap</code> to give yourself access to
        the raw JSON AST:
</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import upickle.default._
case class Bar(i: Int, s: String)
implicit val fooReadWrite: ReadWriter[Bar] =
  readwriter[ujson.Value].bimap[Bar](
    x =&gt; ujson.Arr(x.s, x.i),
    json =&gt; new Bar(json(1).num.toInt, json(0).str)
  )

write(Bar(123, &quot;abc&quot;)) ==&gt; &quot;&quot;&quot;[&quot;abc&quot;,123]&quot;&quot;&quot;
read[Bar](&quot;&quot;&quot;[&quot;abc&quot;,123]&quot;&quot;&quot;) ==&gt; Bar(123, &quot;abc&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L292-L302" target="_blank"><i class="fa fa-link "></i></a></pre>

    <h1 id="CustomKeys" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#CustomKeys" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Custom Keys</h1>
      <p>

        uPickle allows you to specify the key that a field is serialized with
        via a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">@key</code> annotation

</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">case class KeyBar(@upickle.implicits.key(&quot;hehehe&quot;) kekeke: Int)
object KeyBar{
  implicit val rw: RW[KeyBar] = macroRW
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L52-L56" target="_blank"><i class="fa fa-link "></i></a></pre>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">write(KeyBar(10))                     ==&gt; &quot;&quot;&quot;{&quot;hehehe&quot;:10}&quot;&quot;&quot;
read[KeyBar](&quot;&quot;&quot;{&quot;hehehe&quot;: 10}&quot;&quot;&quot;)    ==&gt; KeyBar(10)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L307-L309" target="_blank"><i class="fa fa-link "></i></a></pre>

      <p>

        Practically, this is useful if you want to rename the field within your
        Scala code while still maintaining backwards compatibility with
        previously-pickled objects. Simple rename the field and add a
        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">@key(&quot;...&quot;)</code> with the old name so uPickle can continue to work
        with the old objects correctly.</p>
      <p>
        You can also use <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">@key</code> to change the name used when pickling
        the case class itself. Normally case classes are pickled without their
        name, but an exception is made for members of sealed hierarchies which
        are tagged with their fully-qualified name. uPickle allows you to use
        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">@key</code> to override what the class is tagged with:
</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">sealed trait A
object A{
  implicit val rw: RW[A] = RW.merge(B.rw, macroRW[C.type])
}
@upickle.implicits.key(&quot;Bee&quot;) case class B(i: Int) extends A
object B{
  implicit val rw: RW[B] = macroRW
}
case object C extends A</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L58-L67" target="_blank"><i class="fa fa-link "></i></a></pre>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">write(B(10))                          ==&gt; &quot;&quot;&quot;{&quot;$type&quot;:&quot;Bee&quot;,&quot;i&quot;:10}&quot;&quot;&quot;
read[B](&quot;&quot;&quot;{&quot;$type&quot;:&quot;Bee&quot;,&quot;i&quot;:10}&quot;&quot;&quot;) ==&gt; B(10)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L311-L313" target="_blank"><i class="fa fa-link "></i></a></pre>



      <p>
        This is useful in cases where:</p>
      <ul>
        <li>
          you wish to rename the class within your Scala code, or move it to a
          different package, but want to preserve backwards compatibility with
          previously pickled instances of that class</li>
        <li>
          you try to tackle the resource issue (bandwidth, storage, CPU) because
          FQNs might get quite long
</li></ul>
    <h1 id="JSONDictionaryFormats" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#JSONDictionaryFormats" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>JSON Dictionary Formats</h1>
      <p>
        By default, serializing a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Map[K, V]</code> generates a nested
        array-of-arrays. This is because not all types <code>K</code> can be
        easily serialized into JSON strings, so keeping them as nested tuples
        preserves the structure of the serialized <code>K</code> values:
</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import upickle.default._

case class FooId(x: Int)
implicit val fooRW: ReadWriter[FooId] = readwriter[Int].bimap[FooId](_.x, FooId(_))

write(FooId(123)) ==&gt; &quot;123&quot;
read[FooId](&quot;123&quot;) ==&gt; FooId(123)

write(Map(FooId(123) -&gt; &quot;hello&quot;, FooId(456) -&gt; &quot;world&quot;)) ==&gt;
  &quot;&quot;&quot;[[123,&quot;hello&quot;],[456,&quot;world&quot;]]&quot;&quot;&quot;

read[Map[FooId, String]](&quot;&quot;&quot;[[123,&quot;hello&quot;],[456,&quot;world&quot;]]&quot;&quot;&quot;) ==&gt;
  Map(FooId(123) -&gt; &quot;hello&quot;, FooId(456) -&gt; &quot;world&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L609-L623" target="_blank"><i class="fa fa-link "></i></a></pre>

      <p>
        For types of <code>K</code> that you want to serialize to JSON strings in
        JSON dictionaries, you can wrap your <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">ReadWriter[K]</code> in a
        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">stringKeyRW</code>.
</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import upickle.default._

case class FooId(x: Int)
implicit val fooRW: ReadWriter[FooId] = stringKeyRW(readwriter[Int].bimap[FooId](_.x, FooId(_)))

write(FooId(123)) ==&gt; &quot;123&quot;
read[FooId](&quot;123&quot;) ==&gt; FooId(123)

write(Map(FooId(123) -&gt; &quot;hello&quot;, FooId(456) -&gt; &quot;world&quot;)) ==&gt;
  &quot;&quot;&quot;{&quot;123&quot;:&quot;hello&quot;,&quot;456&quot;:&quot;world&quot;}&quot;&quot;&quot;

read[Map[FooId, String]](&quot;&quot;&quot;{&quot;123&quot;:&quot;hello&quot;,&quot;456&quot;:&quot;world&quot;}&quot;&quot;&quot;) ==&gt;
  Map(FooId(123) -&gt; &quot;hello&quot;, FooId(456) -&gt; &quot;world&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L625-L638" target="_blank"><i class="fa fa-link "></i></a></pre>

      <p>
        Note that this only works for types <code>K</code> which serialize to JSON
        primitives: numbers, strings, booleans, and so on. Types of <code>K</code>
        that serialize to complex structures like JSON arrays or dictionaries
        are unsupported for use a JSON dictionary keys.
</p>
      <p>
        Older versions of uPickle serialized almost all <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Map[K, V]</code>s to
        nested arrays. Data already serialized in that format is forwards-compatible
        with the current implementation of uPickle, which can read both nested-json-arrays
        and json-dictionary formats without issue.
</p>
      <p>
        These subtleties around deciding between nested-json-array v.s. json-dictionary
        formats only apply to uPickle's JSON backend. When serializing to MessagePack
        using <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">upickle.default.writeBinary</code> or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">upickle.default.writeMsg</code>,
        it always uses the dictionary-based format, since MessagePack does not have
        the restriction that dictionary keys can only be strings:
</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import upickle.default._

write(Map(Seq(1) -&gt; 1, Seq(1, 2) -&gt; 3, Seq(1, 2, 3) -&gt; 6)) ==&gt; &quot;[[[1],1],[[1,2],3],[[1,2,3],6]]&quot;

read[Map[Seq[Int], Int]](&quot;[[[1],1],[[1,2],3],[[1,2,3],6]]&quot;) ==&gt;
  Map(Seq(1) -&gt; 1, Seq(1, 2) -&gt; 3, Seq(1, 2, 3) -&gt; 6)

writeMsg(Map(Seq(1) -&gt; 1, Seq(1, 2) -&gt; 3, Seq(1, 2, 3) -&gt; 6)) ==&gt;
  upack.Obj(
    upack.Arr(upack.Int32(1)) -&gt; upack.Int32(1),
    upack.Arr(upack.Int32(1), upack.Int32(2)) -&gt; upack.Int32(3),
    upack.Arr(upack.Int32(1), upack.Int32(2), upack.Int32(3)) -&gt; upack.Int32(6)
  )

readBinary[Map[Seq[Int], Int]](
  upack.Obj(
    upack.Arr(upack.Int32(1)) -&gt; upack.Int32(1),
    upack.Arr(upack.Int32(1), upack.Int32(2)) -&gt; upack.Int32(3),
    upack.Arr(upack.Int32(1), upack.Int32(2), upack.Int32(3)) -&gt; upack.Int32(6)
  )
) ==&gt;
  Map(Seq(1) -&gt; 1, Seq(1, 2) -&gt; 3, Seq(1, 2, 3) -&gt; 6)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L640-L662" target="_blank"><i class="fa fa-link "></i></a></pre>

    <h1 id="CustomConfiguration" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#CustomConfiguration" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Custom Configuration</h1>
      <p>
        Often, there will be times that you want to customize something on a
        project-wide level. uPickle provides hooks in letting you subclass the
        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">upickle.Api</code> trait to create your own bundles apart from the
        in-built <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">upickle.default</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">upickle.legacy</code>. The
        following example demonstrates how to customize a bundle to
        automatically <code>snake_case</code> all dictionary keys.

        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">object SnakePickle extends upickle.AttributeTagged{
  def camelToSnake(s: String) = {
    s.replaceAll(&quot;([A-Z])&quot;,&quot;#$1&quot;).split('#').map(_.toLowerCase).mkString(&quot;_&quot;)
  }
  def snakeToCamel(s: String) = {
    val res = s.split(&quot;_&quot;, -1).map(x =&gt; s&quot;${x(0).toUpper}${x.drop(1)}&quot;).mkString
    s&quot;${s(0).toLower}${res.drop(1)}&quot;
  }

  override def objectAttributeKeyReadMap(s: CharSequence) =
    snakeToCamel(s.toString)
  override def objectAttributeKeyWriteMap(s: CharSequence) =
    camelToSnake(s.toString)

  override def objectTypeKeyReadMap(s: CharSequence) =
    snakeToCamel(s.toString)
  override def objectTypeKeyWriteMap(s: CharSequence) =
    camelToSnake(s.toString)
}

// Default read-writing
upickle.default.write(Thing(1, &quot;gg&quot;)) ==&gt;
  &quot;&quot;&quot;{&quot;myFieldA&quot;:1,&quot;myFieldB&quot;:&quot;gg&quot;}&quot;&quot;&quot;

upickle.default.read[Thing](&quot;&quot;&quot;{&quot;myFieldA&quot;:1,&quot;myFieldB&quot;:&quot;gg&quot;}&quot;&quot;&quot;) ==&gt;
  Thing(1, &quot;gg&quot;)

implicit def thingRW: SnakePickle.ReadWriter[Thing] = SnakePickle.macroRW

// snake_case_keys read-writing
SnakePickle.write(Thing(1, &quot;gg&quot;)) ==&gt;
  &quot;&quot;&quot;{&quot;my_field_a&quot;:1,&quot;my_field_b&quot;:&quot;gg&quot;}&quot;&quot;&quot;

SnakePickle.read[Thing](&quot;&quot;&quot;{&quot;my_field_a&quot;:1,&quot;my_field_b&quot;:&quot;gg&quot;}&quot;&quot;&quot;) ==&gt;
  Thing(1, &quot;gg&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L315-L350" target="_blank"><i class="fa fa-link "></i></a></pre>
</p>
      <p>
        If you are using uPickle to convert JSON from another source into Scala
        data structures, you can also configure it to map <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Option[T]</code>s
        to <code>null</code>s when the option is <code>None</code>:
</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">object OptionPickler extends upickle.AttributeTagged {
  override implicit def OptionWriter[T: Writer]: Writer[Option[T]] =
    implicitly[Writer[T]].comap[Option[T]] {
      case None =&gt; null.asInstanceOf[T]
      case Some(x) =&gt; x
    }

  override implicit def OptionReader[T: Reader]: Reader[Option[T]] = {
    new Reader.Delegate[Any, Option[T]](implicitly[Reader[T]].map(Some(_))){
      override def visitNull(index: Int) = None
    }
  }
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/OptionsAsNullTests.scala#L10-L23" target="_blank"><i class="fa fa-link "></i></a></pre>

      <p>
        This custom configuration allows you to treat <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">null</code>s as
        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">None</code>s and anything else as <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Some(...)</code>s. Simply
        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import OptionPickler._</code> instead of the normal uPickle import
        throughout your project and you'll have the customized reading/writing
        available to you.
</p>
      <p>
        You can also use a custom configuration to change how 64-bit <code>Long</code>s are
        handled. By default, small longs that can be represented exactly in 64-bit
        <code>Double</code>s are written as raw numbers, while larger values (n &gt; 2^53)
        are written as strings. This is to ensure the values are not truncated when
        the serialized JSON is then manipulated, e.g. by Javascript which truncates
        all large numbers to Doubles. If you wish to always write Longs as Strings,
        or always write them as numbers (at risk of truncation), you can do so as
        follows:
</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">upickle.default.write(123: Long) ==&gt; &quot;123&quot;
upickle.default.write(Long.MaxValue) ==&gt; &quot;\&quot;9223372036854775807\&quot;&quot;

object StringLongs extends upickle.AttributeTagged{
  override implicit val LongWriter: Writer[Long] = new Writer[Long] {
    def write0[V](out: Visitor[_, V], v: Long) = out.visitString(v.toString, -1)
  }
}

StringLongs.write(123: Long) ==&gt; &quot;\&quot;123\&quot;&quot;
StringLongs.write(Long.MaxValue) ==&gt; &quot;\&quot;9223372036854775807\&quot;&quot;

object NumLongs extends upickle.AttributeTagged{
  override implicit val LongWriter: Writer[Long] = new Writer[Long] {
    def write0[V](out: Visitor[_, V], v: Long) = out.visitFloat64String(v.toString, -1)
  }
}

NumLongs.write(123: Long) ==&gt; &quot;123&quot;
NumLongs.write(Long.MaxValue) ==&gt; &quot;9223372036854775807&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L353-L374" target="_blank"><i class="fa fa-link "></i></a></pre>


  <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Limitations" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Limitations<a class=" scalatex-site-Styles-headerLink" href="#Limitations" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>

    <p>
      uPickle doesn't currently support:</p>
    <ul>
      <li>
        Circular object graphs</li>
      <li>
        Reflective reading and writing</li>
      <li>
        Read/writing of untyped values e.g. <code>Any</code></li>
      <li>
        Read/writing arbitrarily shaped objects</li>
      <li>
        Read/writing case classes with multiple parameter lists.</li></ul>
    <p>
      Most of these limitations are inherent in the fact that ScalaJS does not
      support reflection, and are unlikely to ever go away. In general, uPickle
      by default can serialize statically-typed, tree-shaped, immutable data
      structures. Anything more complex requires <a href="#CustomPicklers">Custom Picklers</a>
</p>
    <h1 id="ManualSealedTraitPicklers" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#ManualSealedTraitPicklers" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Manual Sealed Trait Picklers</h1>
      <p>
        Due to a bug in the Scala compiler SI-7046, automatic sealed trait
        pickling can fail unpredictably. This can be worked around by instead
        using the <code>macroRW</code> and <code>merge</code> methods to manually specify
        which sub-types of a sealed trait to consider when pickling:
</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">sealed trait TypedFoo
object TypedFoo{
  import upickle.default._
  implicit val readWriter: ReadWriter[TypedFoo] = ReadWriter.merge(
    macroRW[Bar], macroRW[Baz], macroRW[Quz]
  )

  case class Bar(i: Int) extends TypedFoo
  case class Baz(s: String) extends TypedFoo
  case class Quz(b: Boolean) extends TypedFoo
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/MacroTests.scala#L47-L58" target="_blank"><i class="fa fa-link "></i></a></pre>

  <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="uJson" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">uJson<a class=" scalatex-site-Styles-headerLink" href="#uJson" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>

    <p>
      uJson is uPickle's JSON library, which can be used to easily
      manipulate JSON source and data structures without converting them into
      Scala case-classes. This all lives in the <code>ujson</code> package. Unlike
      many other Scala JSON libraries that come with their own zoo of new
      concepts, abstractions, and techniques, uJson has a simple &amp; predictable
      JSON API that should be instantly familiar to anyone coming from
      scripting languages like Ruby, Python or Javascript.
</p>
    <p>
      uJson comes bundled with uPickle, or can be used stand-alone via the
      following package coordinates:
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">libraryDependencies += &quot;com.lihaoyi&quot; %% &quot;ujson&quot; % &quot;0.9.6&quot;
</code></pre>
    <h1 id="Construction" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Construction" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Construction</h1>
      <p>
        You can use <code>ujson</code> to conveniently construct JSON blobs, either
        programmatically:</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">
        val json0 = ujson.Arr(
          ujson.Obj(&quot;myFieldA&quot; -&gt; ujson.Num(1), &quot;myFieldB&quot; -&gt; ujson.Str(&quot;g&quot;)),
          ujson.Obj(&quot;myFieldA&quot; -&gt; ujson.Num(2), &quot;myFieldB&quot; -&gt; ujson.Str(&quot;k&quot;))
        )

        val json = ujson.Arr( // The `ujson.Num` and `ujson.Str` calls are optional
          ujson.Obj(&quot;myFieldA&quot; -&gt; 1, &quot;myFieldB&quot; -&gt; &quot;g&quot;),
          ujson.Obj(&quot;myFieldA&quot; -&gt; 2, &quot;myFieldB&quot; -&gt; &quot;k&quot;)
        )

        json0 ==&gt; json</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L444-L456" target="_blank"><i class="fa fa-link "></i></a></pre>

      <p>
        Or parsing them from strings, byte arrays or files:
</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val str = &quot;&quot;&quot;[{&quot;myFieldA&quot;:1,&quot;myFieldB&quot;:&quot;g&quot;},{&quot;myFieldA&quot;:2,&quot;myFieldB&quot;:&quot;k&quot;}]&quot;&quot;&quot;
val json = ujson.read(str)
json(0)(&quot;myFieldA&quot;).num   ==&gt; 1
json(0)(&quot;myFieldB&quot;).str   ==&gt; &quot;g&quot;
json(1)(&quot;myFieldA&quot;).num   ==&gt; 2
json(1)(&quot;myFieldB&quot;).str   ==&gt; &quot;k&quot;

ujson.write(json)         ==&gt; str</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L466-L474" target="_blank"><i class="fa fa-link "></i></a></pre>

      <p>
        <code>ujson.Js</code> ASTs are mutable, and can be modified before being re-serialized
        to strings:
</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val str = &quot;&quot;&quot;[{&quot;myFieldA&quot;:1,&quot;myFieldB&quot;:&quot;g&quot;},{&quot;myFieldA&quot;:2,&quot;myFieldB&quot;:&quot;k&quot;}]&quot;&quot;&quot;
val json: ujson.Value = ujson.read(str)

json.arr.remove(1)
json(0)(&quot;myFieldA&quot;) = 1337
json(0)(&quot;myFieldB&quot;) = json(0)(&quot;myFieldB&quot;).str + &quot;lols&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L476-L483" target="_blank"><i class="fa fa-link "></i></a></pre>

      <p>
        You can also use the `_` shorthand syntax to update a JSON value in
        place, without having to duplicate the whole path:
</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val str = &quot;&quot;&quot;[{&quot;myFieldA&quot;:1,&quot;myFieldB&quot;:&quot;g&quot;},{&quot;myFieldA&quot;:2,&quot;myFieldB&quot;:&quot;k&quot;}]&quot;&quot;&quot;
val json: ujson.Value = ujson.read(str)

json(0)(&quot;myFieldA&quot;) = _.num + 100
json(1)(&quot;myFieldB&quot;) = _.str + &quot;lol&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L486-L492" target="_blank"><i class="fa fa-link "></i></a></pre>

      <p>
        case classes or other Scala data structures can be converted to
        <code>ujson.Js</code> ASTs using <code>upickle.default.writeJs</code>, and the
        <code>ujson.Js</code> ASTs can be converted back using <code>upickle.default.readJs</code>
        or plain <code>upickle.default.read</code>:
</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val data = Seq(Thing(1, &quot;g&quot;), Thing(2, &quot;k&quot;))
val json = upickle.default.writeJs(data)

json.arr.remove(1)
json(0)(&quot;myFieldA&quot;) = 1337

upickle.default.read[Seq[Thing]](json)   ==&gt; Seq(Thing(1337, &quot;g&quot;))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L496-L503" target="_blank"><i class="fa fa-link "></i></a></pre>

    <h1 id="JSONUtilities" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#JSONUtilities" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>JSON Utilities</h1>
      <p>
        uJson comes with some convenient utilities on the `ujson` package:
</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def transform[T](t: Readable,
                 v: upickle.core.Visitor[_, T],
                 sortKeys: Boolean = false): T = {
  BufferedValue.maybeSortKeysTransform(Readable, t, sortKeys, v)
}

  @deprecated(&quot;Binary Compatibility Stub&quot;, &quot;upickle after 3.1.4&quot;)
def transform[T](t: Readable,
                 v: upickle.core.Visitor[_, T]): T = transform(t, v, sortKeys = false)
/**
  * Read the given JSON input as a JSON struct
  */
def read(s: Readable, trace: Boolean = false): Value.Value =
  upickle.core.TraceVisitor.withTrace(trace, Value)(transform(s, _))

def copy(t: Value.Value): Value.Value = transform(t, Value)

/**
  * Write the given JSON struct as a JSON String
  */
def write(t: Value.Value,
          indent: Int = -1,
          escapeUnicode: Boolean = false,
          sortKeys: Boolean = false): String = {
  val writer = new java.io.StringWriter
  writeTo(t, writer, indent, escapeUnicode, sortKeys)
  writer.toString
}

// @deprecated(&quot;Binary Compatibility Stub&quot;, &quot;upickle after 3.1.4&quot;)
def write(t: Value.Value,
          indent: Int,
          escapeUnicode: Boolean): String = {
  write(t, indent, escapeUnicode, sortKeys = false)
}

/**
  * Write the given JSON struct as a JSON String to the given Writer
  */
def writeTo(t: Value.Value,
            out: java.io.Writer,
            indent: Int = -1,
            escapeUnicode: Boolean = false,
            sortKeys: Boolean = false): Unit = {
  transform(t, Renderer(out, indent, escapeUnicode), sortKeys)
}

// @deprecated(&quot;Binary Compatibility Stub&quot;, &quot;upickle after 3.1.4&quot;)
def writeTo(t: Value.Value,
            out: java.io.Writer,
            indent: Int,
            escapeUnicode: Boolean): Unit = {
  writeTo(t, out, indent, escapeUnicode, sortKeys = false)
}

def writeToOutputStream(t: Value.Value,
                        out: java.io.OutputStream,
                        indent: Int = -1,
                        escapeUnicode: Boolean = false,
                        sortKeys: Boolean = false): Unit = {
  transform(t, new BaseByteRenderer(out, indent, escapeUnicode), sortKeys)
}

// @deprecated(&quot;Binary Compatibility Stub&quot;, &quot;upickle after 3.1.4&quot;)
def writeToOutputStream(t: Value.Value,
                        out: java.io.OutputStream,
                        indent: Int,
                        escapeUnicode: Boolean): Unit = {
  writeToOutputStream(t, out, indent, escapeUnicode, sortKeys = false)
}

def writeToByteArray(t: Value.Value,
                     indent: Int = -1,
                     escapeUnicode: Boolean = false,
                     sortKeys: Boolean = false): Array[Byte] = {
  val baos = new java.io.ByteArrayOutputStream
  writeToOutputStream(t, baos, indent, escapeUnicode, sortKeys)
  baos.toByteArray
}

// @deprecated(&quot;Binary Compatibility Stub&quot;, &quot;upickle after 3.1.4&quot;)
def writeToByteArray(t: Value.Value,
                     indent: Int,
                     escapeUnicode: Boolean): Array[Byte] = {
  writeToByteArray(t, indent, escapeUnicode, sortKeys = false)
}

/**
  * Parse the given JSON input, failing if it is invalid
  */
def validate(s: Readable): Unit = transform(s, NoOpVisitor)
/**
  * Parse the given JSON input and write it to a string with
  * the configured formatting
  */
def reformat(s: Readable,
             indent: Int = -1,
             escapeUnicode: Boolean = false,
             sortKeys: Boolean = false): String = {
  val writer = new java.io.StringWriter()
  reformatTo(s, writer, indent, escapeUnicode, sortKeys)
  writer.toString
}

// @deprecated(&quot;Binary Compatibility Stub&quot;, &quot;upickle after 3.1.4&quot;)
def reformat(s: Readable,
             indent: Int,
             escapeUnicode: Boolean): String = {
  reformat(s, indent, escapeUnicode, sortKeys = false)
}
/**
  * Parse the given JSON input and write it to a string with
  * the configured formatting to the given Writer
  */
def reformatTo(s: Readable,
               out: java.io.Writer,
               indent: Int = -1,
               escapeUnicode: Boolean = false,
               sortKeys: Boolean = false): Unit = {
  transform(s, Renderer(out, indent, escapeUnicode), sortKeys)
}

// @deprecated(&quot;Binary Compatibility Stub&quot;, &quot;upickle after 3.1.4&quot;)
def reformatTo(s: Readable,
               out: java.io.Writer,
               indent: Int,
               escapeUnicode: Boolean): Unit = {
  reformatTo(s, out, indent, escapeUnicode, sortKeys = false)
}
/**
  * Parse the given JSON input and write it to a string with
  * the configured formatting to the given Writer
  */
def reformatToOutputStream(s: Readable,
                           out: java.io.OutputStream,
                           indent: Int = -1,
                           escapeUnicode: Boolean = false,
                           sortKeys: Boolean = false): Unit = {
  transform(s, new BaseByteRenderer(out, indent, escapeUnicode), sortKeys)
}

// @deprecated(&quot;Binary Compatibility Stub&quot;, &quot;upickle after 3.1.4&quot;)
def reformatToOutputStream(s: Readable,
                           out: java.io.OutputStream,
                           indent: Int,
                           escapeUnicode: Boolean): Unit = {
  reformatToOutputStream(s, out, indent, escapeUnicode, sortKeys = false)
}

def reformatToByteArray(s: Readable,
                        indent: Int = -1,
                        escapeUnicode: Boolean = false,
                        sortKeys: Boolean = false): Array[Byte] = {
  val baos = new java.io.ByteArrayOutputStream
  reformatToOutputStream(s, baos, indent, escapeUnicode, sortKeys)
  baos.toByteArray
}

// @deprecated(&quot;Binary Compatibility Stub&quot;, &quot;upickle after 3.1.4&quot;)
def reformatToByteArray(s: Readable,
                        indent: Int,
                        escapeUnicode: Boolean): Array[Byte] = {
  reformatToByteArray(s, indent, escapeUnicode, sortKeys = false)
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/ujson/src/ujson/package.scala#L4-L168" target="_blank"><i class="fa fa-link "></i></a></pre>

    <h1 id="Transformations" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Transformations" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Transformations</h1>
      <p>
        uJson allows you seamlessly convert between any of the following forms
        you may find your JSON in:
</p>
      <ul>
        <li>
          Case classes &amp; Scala data-types</li>
        <li>
          <code>ujson.Js</code> ASTs</li>
        <li>
          <code>String</code>s</li>
        <li>
          <code>CharSequence</code>s</li>
        <li>
          <code>Array[Byte]</code>s</li>
        <li>
          Third-party JSON ASTs (Argonaut, Circe, Json4s, Play-Json)</li></ul>
      <p>
        This is done using the <code>ujson.transform(source, dest)</code> function:
</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">// It can be used for parsing JSON into an AST
val exampleAst = ujson.Arr(1, 2, 3)

ujson.transform(&quot;[1, 2, 3]&quot;, Value) ==&gt; exampleAst

// Rendering the AST to a string
ujson.transform(exampleAst, StringRenderer()).toString ==&gt; &quot;[1,2,3]&quot;

// Or to a byte array
ujson.transform(exampleAst, BytesRenderer()).toByteArray ==&gt; &quot;[1,2,3]&quot;.getBytes

// Re-formatting JSON, either compacting it
ujson.transform(&quot;[1, 2, 3]&quot;, StringRenderer()).toString ==&gt; &quot;[1,2,3]&quot;

// or indenting it
ujson.transform(&quot;[1, 2, 3]&quot;, StringRenderer(indent = 4)).toString ==&gt;
  &quot;&quot;&quot;[
    |    1,
    |    2,
    |    3
    |]&quot;&quot;&quot;.stripMargin

// `transform` takes any `Transformable`, including byte arrays and files
ujson.transform(&quot;[1, 2, 3]&quot;.getBytes, StringRenderer()).toString ==&gt; &quot;[1,2,3]&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L551-L576" target="_blank"><i class="fa fa-link "></i></a></pre>

      <p>
        All transformations from A to B using <code>ujson.transform</code> happen
        in a direct fashion: there are no intermediate JSON ASTs being generated,
        and performance is generally very good.
</p>
      <p>
        You can use <code>ujson.transform</code> to validate JSON in a streaming
        fashion:
</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">test {
  ujson.transform(&quot;[1, 2, 3]&quot;, NoOpVisitor)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L578-L580" target="_blank"><i class="fa fa-link "></i></a></pre>

      <p>
        The normal <code>upickle.default.read/write</code> methods to serialize Scala
        data-types is just shorthand for ujson.transform,
        using a <code>upickle.default.transform(foo)</code> as the source or a
        <code>upickle.default.reader[Foo]</code> as the destination:
</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">ujson.transform(&quot;[1, 2, 3]&quot;, upickle.default.reader[Seq[Int]]) ==&gt;
  Seq(1, 2, 3)

ujson.transform(upickle.default.transform(Seq(1, 2, 3)), StringRenderer()).toString ==&gt;
  &quot;[1,2,3]&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L593-L598" target="_blank"><i class="fa fa-link "></i></a></pre>

    <h1 id="OtherASTs" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#OtherASTs" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Other ASTs</h1>
      <p>
        uJson does not provide any other utilities are JSON that other libraries
        do: zippers, lenses, combinators, etc.. However, uJson can be used to
        seamlessly convert between the JSON AST of other libraries! This means
        if some other library provides a more convenient API for some kind of
        processing you need to do, you can easily parse to that library's AST,
        do whatever you need, and convert back after.
</p>
      <p>
        As mentioned earlier, conversions are fast and direct, and happen
        without creating intermediate JSON structures in the process. The
        following examples demonstrate how to use the conversion modules for
        <a href="http://argonaut.io/doc/">Argonaut</a>,
        <a href="https://github.com/circe/circe">Circe</a>,
        <a href="https://github.com/json4s/json4s">Json4s</a>, and
        <a href="https://github.com/playframework/play-json">Play Json</a>.</p>
      <p>
        Each example parses JSON from a string into that particular library's
        JSON AST, manipulates the AST using that library, un-pickles it into
        Scala data types, then serializes those data types first into that
        library's AST then back to a string.
</p>
      <h2 id="Argonaut" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Argonaut" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Argonaut</h2>
        <b>Maven Coordinates</b>

        <pre><code class="scala scalatex-site-Styles-highlightMe">libraryDependencies += &quot;com.lihaoyi&quot; %% &quot;ujson-argonaut&quot; % &quot;0.9.6&quot;
</code></pre>
        <b>Usage</b>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val argJson: argonaut.Json = ArgonautJson(
  &quot;&quot;&quot;[&quot;hello&quot;, &quot;world&quot;]&quot;&quot;&quot;
)

val updatedArgJson = argJson.withArray(_.map(_.withString(_.toUpperCase)))

val items: Seq[String] = ArgonautJson.transform(
  updatedArgJson,
  upickle.default.reader[Seq[String]]
)

items ==&gt; Seq(&quot;HELLO&quot;, &quot;WORLD&quot;)

val rewritten = upickle.default.transform(items).to(ArgonautJson)

val stringified = ArgonautJson.transform(rewritten, StringRenderer()).toString

stringified ==&gt; &quot;&quot;&quot;[&quot;HELLO&quot;,&quot;WORLD&quot;]&quot;&quot;&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src-jvm-2/upickle/example/JvmExampleTests.scala#L28-L46" target="_blank"><i class="fa fa-link "></i></a></pre>

      <h2 id="Circe" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Circe" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Circe</h2>
        <b>Maven Coordinates</b>
        <pre><code class="scala scalatex-site-Styles-highlightMe">libraryDependencies += &quot;com.lihaoyi&quot; %% &quot;ujson-circe&quot; % &quot;0.9.6&quot;</code></pre>
        <b>Usage</b>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val circeJson: io.circe.Json = CirceJson(
  &quot;&quot;&quot;[&quot;hello&quot;, &quot;world&quot;]&quot;&quot;&quot;
)

val updatedCirceJson =
  circeJson.mapArray(_.map(x =&gt; x.mapString(_.toUpperCase)))

val items: Seq[String] = CirceJson.transform(
  updatedCirceJson,
  upickle.default.reader[Seq[String]]
)

items ==&gt; Seq(&quot;HELLO&quot;, &quot;WORLD&quot;)

val rewritten = upickle.default.transform(items).to(CirceJson)

val stringified = CirceJson.transform(rewritten, StringRenderer()).toString

stringified ==&gt; &quot;&quot;&quot;[&quot;HELLO&quot;,&quot;WORLD&quot;]&quot;&quot;&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src-jvm-2/upickle/example/JvmExampleTests.scala#L48-L67" target="_blank"><i class="fa fa-link "></i></a></pre>

      <h2 id="Play-Json" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Play-Json" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Play-Json</h2>
        <b>Maven Coordinates</b>
        <pre><code class="scala scalatex-site-Styles-highlightMe">libraryDependencies += &quot;com.lihaoyi&quot; %% &quot;ujson-play&quot; % &quot;0.9.6&quot;</code></pre>
        <b>Usage</b>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import play.api.libs.json._
val playJson: play.api.libs.json.JsValue = PlayJson(
  &quot;&quot;&quot;[&quot;hello&quot;, &quot;world&quot;]&quot;&quot;&quot;
)

val updatedPlayJson = JsArray(
  for(v &lt;- playJson.as[JsArray].value)
    yield JsString(v.as[String].toUpperCase())
)

val items: Seq[String] = PlayJson.transform(
  updatedPlayJson,
  upickle.default.reader[Seq[String]]
)

items ==&gt; Seq(&quot;HELLO&quot;, &quot;WORLD&quot;)

val rewritten = upickle.default.transform(items).to(PlayJson)

val stringified = PlayJson.transform(rewritten, StringRenderer()).toString

stringified ==&gt; &quot;&quot;&quot;[&quot;HELLO&quot;,&quot;WORLD&quot;]&quot;&quot;&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src-jvm-2/upickle/example/JvmExampleTests.scala#L93-L115" target="_blank"><i class="fa fa-link "></i></a></pre>

      <h2 id="Json4s" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Json4s" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Json4s</h2>
        <b>Maven Coordinates</b>
        <pre><code class="scala scalatex-site-Styles-highlightMe">libraryDependencies += &quot;com.lihaoyi&quot; %% &quot;ujson-json4s&quot; % &quot;0.9.6&quot;</code></pre>
        <b>Usage</b>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import org.json4s.JsonAST
val json4sJson: JsonAST.JValue = Json4sJson(
  &quot;&quot;&quot;[&quot;hello&quot;, &quot;world&quot;]&quot;&quot;&quot;
)

val updatedJson4sJson = JsonAST.JArray(
  for(v &lt;- json4sJson.children)
    yield JsonAST.JString(v.values.toString.toUpperCase())
)

val items: Seq[String] = Json4sJson.transform(
  updatedJson4sJson,
  upickle.default.reader[Seq[String]]
)

items ==&gt; Seq(&quot;HELLO&quot;, &quot;WORLD&quot;)

val rewritten = upickle.default.transform(items).to(Json4sJson)

val stringified = Json4sJson.transform(rewritten, StringRenderer()).toString

stringified ==&gt; &quot;&quot;&quot;[&quot;HELLO&quot;,&quot;WORLD&quot;]&quot;&quot;&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src-jvm-2/upickle/example/JvmExampleTests.scala#L69-L91" target="_blank"><i class="fa fa-link "></i></a></pre>

      <h2 id="Cross-LibraryConversions" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Cross-LibraryConversions" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Cross-Library Conversions</h2>
        <p>
          uJson lets you convert between third-party ASTs efficiently and with
          minimal overhead: uJson converts one AST to the other directly
          and without any temporary compatibility data structures. The following
          example demonstrates how this is done: we parse a JSON string using
          Circe, perform some transformation, convert it to a Play-Json AST,
          perform more transformations, and finally serialize it back to a
          String and check that both transformations were applied:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val circeJson: io.circe.Json = CirceJson(
  &quot;&quot;&quot;[&quot;hello&quot;, &quot;world&quot;]&quot;&quot;&quot;
)

val updatedCirceJson =
  circeJson.mapArray(_.map(x =&gt; x.mapString(_.toUpperCase)))

import play.api.libs.json._

val playJson: play.api.libs.json.JsValue = CirceJson.transform(
  updatedCirceJson,
  PlayJson
)

val updatedPlayJson = JsArray(
  for(v &lt;- playJson.as[JsArray].value)
    yield JsString(v.as[String].reverse)
)

val stringified = PlayJson.transform(updatedPlayJson, StringRenderer()).toString

stringified ==&gt; &quot;&quot;&quot;[&quot;OLLEH&quot;,&quot;DLROW&quot;]&quot;&quot;&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src-jvm-2/upickle/example/JvmExampleTests.scala#L117-L139" target="_blank"><i class="fa fa-link "></i></a></pre>

  <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="uPack" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">uPack<a class=" scalatex-site-Styles-headerLink" href="#uPack" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>

    <p>
      uPack is uPickle's MessagePack library, which can be used to easily
      manipulate MessagePack source and data structures without converting them into
      Scala case-classes. This all lives in the <code>upack</code> package.</p>
    <p>
      uPack comes bundled with uPickle, or can be used stand-alone via the
      following package coordinates:
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">libraryDependencies += &quot;com.lihaoyi&quot; %% &quot;upack&quot; % &quot;0.9.6&quot;
</code></pre>
    <p>
      The following basic functions are provided in the <code>upack</code> package
      to let you read and write MessagePack structs:
</p>
    <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def transform[T](t: Readable, v: upickle.core.Visitor[_, T]) = t.transform(v)

/**
  * Read the given MessagePack input into a MessagePack struct
  */
def read(s: Readable, trace: Boolean = false): Msg = upickle.core.TraceVisitor.withTrace(trace, Msg)(transform(s, _))

def copy(t: Msg): Msg = transform(t, Msg)
/**
  * Write the given MessagePack struct as a binary
  */
def write(t: Msg): Array[Byte] = {
  transform(t, new MsgPackWriter()).toByteArray
}
/**
  * Write the given MessagePack struct as a binary to the given OutputStream
  */
def writeTo(t: Msg, out: java.io.OutputStream): Unit = {
  transform(t, new MsgPackWriter(out))
}
def writeToByteArray(t: Msg) = {
  val out = new ByteArrayOutputStream()
  transform(t, new MsgPackWriter(out))
  out.toByteArray
}
/**
  * Parse the given MessagePack input, failing if it is invalid
  */
def validate(s: Readable): Unit = transform(s, NoOpVisitor)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upack/src/upack/package.scala#L5-L34" target="_blank"><i class="fa fa-link "></i></a></pre>

    <p>
      MessagePack structs are represented using the <code>upack.Msg</code> type.
      You can construct ad-hoc MessagePack structs using <code>upack.Msg</code>, and
      can similarly parse binary data into <code>upack.Msg</code> for ad-hoc querying
      and manipulation, without needing to bind it to Scala case classes or data
      types:
</p>
    <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val msg = upack.Arr(
  upack.Obj(upack.Str(&quot;myFieldA&quot;) -&gt; upack.Int32(1), upack.Str(&quot;myFieldB&quot;) -&gt; upack.Str(&quot;g&quot;)),
  upack.Obj(upack.Str(&quot;myFieldA&quot;) -&gt; upack.Int32(2), upack.Str(&quot;myFieldB&quot;) -&gt; upack.Str(&quot;k&quot;))
)

val binary: Array[Byte] = upack.write(msg)

val read = upack.read(binary)
assert(msg == read)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L393-L402" target="_blank"><i class="fa fa-link "></i></a></pre>

    <p>
      You can read/write Scala values to <code>upack.Msg</code>s using <code>readBinary</code>/<code>writeMsg</code>:
</p>
    <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val big = Big(1, true, &quot;lol&quot;, 'Z', Thing(7, &quot;&quot;))
val msg: upack.Msg = upickle.default.writeMsg(big)
upickle.default.readBinary[Big](msg) ==&gt; big</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L405-L408" target="_blank"><i class="fa fa-link "></i></a></pre>

    <p>
      Or include <code>upack.Msg</code>s inside <code>Seq</code>s, case-classes and other
      data structures when you read/write them:
</p>
    <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val msgSeq = Seq[upack.Msg](
  upack.Str(&quot;hello world&quot;),
  upack.Arr(upack.Int32(1), upack.Int32(2))
)

val binary: Array[Byte] = upickle.default.writeBinary(msgSeq)

upickle.default.readBinary[Seq[upack.Msg]](binary) ==&gt; msgSeq</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L411-L419" target="_blank"><i class="fa fa-link "></i></a></pre>

    <p>
      You can also convert the uPack messages or binaries to <code>ujson.Value</code>s via
      <code>upack.transform</code>. This can be handy to help debug what's going on in your
      binary message data:
</p>
    <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val msg = upack.Arr(
  upack.Obj(upack.Str(&quot;myFieldA&quot;) -&gt; upack.Int32(1), upack.Str(&quot;myFieldB&quot;) -&gt; upack.Str(&quot;g&quot;)),
  upack.Obj(upack.Str(&quot;myFieldA&quot;) -&gt; upack.Int32(2), upack.Str(&quot;myFieldB&quot;) -&gt; upack.Str(&quot;k&quot;))
)

val binary: Array[Byte] = upack.write(msg)

// Can pretty-print starting from either the upack.Msg structs,
// or the raw binary data
upack.transform(msg, new ujson.StringRenderer()).toString ==&gt;
  &quot;&quot;&quot;[{&quot;myFieldA&quot;:1,&quot;myFieldB&quot;:&quot;g&quot;},{&quot;myFieldA&quot;:2,&quot;myFieldB&quot;:&quot;k&quot;}]&quot;&quot;&quot;

upack.transform(binary, new ujson.StringRenderer()).toString ==&gt;
  &quot;&quot;&quot;[{&quot;myFieldA&quot;:1,&quot;myFieldB&quot;:&quot;g&quot;},{&quot;myFieldA&quot;:2,&quot;myFieldB&quot;:&quot;k&quot;}]&quot;&quot;&quot;

// Some messagepack structs cannot be converted to valid JSON, e.g.
// they may have maps with non-string keys. These can still be pretty-printed:
val msg2 = upack.Obj(upack.Arr(upack.Int32(1), upack.Int32(2)) -&gt; upack.Int32(1))
upack.transform(msg2, new ujson.StringRenderer()).toString ==&gt; &quot;&quot;&quot;{&quot;[1,2]&quot;:1}&quot;&quot;&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/upickle/tree/main/upickle/test/src/upickle/example/ExampleTests.scala#L422-L441" target="_blank"><i class="fa fa-link "></i></a></pre>

    <p>
      Note that such a conversion between MessagePack structs and JSON data is
      lossy: some MessagePack constructs, such as binary data, cannot be exactly
      represented in JSON and have to be converted to strings. Thus you should
      not rely on being able to round-trip data between JSON &lt;-&gt; MessagePack and
      getting the same thing back, although round tripping data between
      Scala-data-types &lt;-&gt; JSON and Scala-data-types &lt;-&gt; MessagePack should
      always work.
</p>
    <p>
      Some of the differences between the ways things are serialized in
      MessagePack and JSON include:
</p>
    <ul>
      <li>
        Large Longs in JSON are represented as <code>ujson.Str</code>s if n &gt; 2^53; in MessagePack,
        they are represented as <code>upack.Int64</code>s or <code>upack.UInt64</code>s</li>
      <li>
        <code>Array[Byte]</code>s in JSON are represented as lists of numbers; in MessagePack,
        they are represented as <code>upack.Binary</code>
</li></ul>
    <p>
      If you need to construct Scala case classes or other data types from your
      MessagePack binary data, you should directly use <code>upickle.default.readBinary</code>
      and <code>upickle.default.writeBinary</code>: these bypass the <code>upack.Msg</code>
      struct entirely for the optimal performance.
</p>
  <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Performance" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Performance<a class=" scalatex-site-Styles-headerLink" href="#Performance" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <p>
      The uPickle has a small set of benchmarks in <code>bench/</code> that tests
      reading and writing performance of a few common JSON libraries on a small,
      somewhat arbitrary workload. The numbers below show how many times each
      library could read/write a small data structure in 25 seconds (bigger
      numbers better). In some libraries, caching the serializers rather than
      re-generating them each read/write also improves performance: that effect
      can be seen in the <code>(Cached)</code> columns.
</p>
    <h1 id="JVMCaseClassSerializationPerformance" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#JVMCaseClassSerializationPerformance" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>JVM Case Class Serialization Performance</h1>
      <p>
        uPickle runs 30-50% faster than Circe for reads/writes, and ~200%
        faster than play-json.
</p>
      <table class="pure-table" style="text-align: right;">
        <thead>
          <tr>
            <th>Library</th>
            <th>Reads</th>
            <th>Writes</th>
            <th>Reads (Cached)</th>
            <th>Write (Cached)</th></tr></thead>
        <tbody>
          <tr>
            <td>Play Json 2.9.2</td>
            <td>331</td>
            <td>296</td>
            <td>361</td>
            <td>309</td></tr>
          <tr>
            <td>Circe 0.13.0</td>
            <td>517</td>
            <td>504</td>
            <td>526</td>
            <td>502</td></tr>
          <tr>
            <td>upickle.default 1.3.0 (JSON Strings)</td>
            <td>809</td>
            <td>728</td>
            <td>822</td>
            <td>864</td></tr>
          <tr>
            <td>upickle.default 1.3.0 (JSON Array[Byte])</td>
            <td>761</td>
            <td>706</td>
            <td>774</td>
            <td>830</td></tr>
          <tr>
            <td>upickle.default 1.3.0 (MsgPack Array[Byte])</td>
            <td>1652</td>
            <td>1264</td>
            <td>1743</td>
            <td>1753</td>
</tr></tbody></table>
      <p>
        As you can see, uPickle's JSON serialization is pretty consistently
        ~50% faster than Circe for reads and writes, and 100-200% faster than
        Play-Json, depending on workload.
</p>
      <p>
        uPickle's binary MessagePack backend is then another 100% faster than
        uPickle JSON.
</p>
      <p>
        uPickle achieves this speed by avoiding the construction of an
        intermediate JSON AST: while most libraries parse from
        <code>String -&gt; AST -&gt; CaseClass</code>, uPickle parses input directly from
        <code>String -&gt; CaseClass</code>. uPickle also provides a <code>ujson.Js</code> AST that
        you can use to manipulate arbitrary JSON, but <code>ujson.Js</code> plays no
        part in parsing things to case-classes and is purely for users who want
        to manipulate JSON.
</p>
    <h1 id="JSCaseClassSerializationPerformance" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#JSCaseClassSerializationPerformance" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>JS Case Class Serialization Performance</h1>
      <p>
        While all libraries are much slower on Scala.js/Node.js
        than on the JVM, uPickle runs
        4-5x as fast as Circe or Play-Json for reads and writes.</p>
      <table class="pure-table" style="text-align: right;">
        <thead>
          <tr>
            <th>Library</th>
            <th>Reads</th>
            <th>Writes</th>
            <th>Reads (Cached)</th>
            <th>Write (Cached)</th></tr></thead>
        <tbody>
          <tr>
            <td>Play Json 2.9.2</td>
            <td>64</td>
            <td>81</td>
            <td>66</td>
            <td>86</td></tr>
          <tr>
            <td>Circe 0.13.0</td>
            <td>98</td>
            <td>121</td>
            <td>99</td>
            <td>99</td></tr>
          <tr>
            <td>upickle.default 1.3.0 (JSON String)</td>
            <td>76</td>
            <td>40</td>
            <td>76</td>
            <td>44</td></tr>
          <tr>
            <td>upickle.default 1.3.0 (JSON Array[Byte]</td>
            <td>68</td>
            <td>107</td>
            <td>69</td>
            <td>112</td></tr>
          <tr>
            <td>upickle.default.web 1.3.0 (JSON String)</td>
            <td>349</td>
            <td>327</td>
            <td>353</td>
            <td>465</td></tr>
          <tr>
            <td>upickle.default 1.3.0 (MsgPack Array[Byte])</td>
            <td>85</td>
            <td>104</td>
            <td>85</td>
            <td>110</td>
</tr></tbody></table>
    <p>
      On Scala.js, uPickle's performance is comparable to othersl ike Play JSON or Circe.
      However, uPickle also exposes the <code>upickle.default.web</code> API, allowing you to
      use the JS runtime's built-in JSON parser to power serialization and deserialization.
      This ends up being 4-6x faster than the Scala-based JSON parsers of all the libraries
      compared (uPickle, Play-JSON, Circe)
</p>
    <p>
      uJson is a fork of Erik Osheim's excellent [Jawn](https://github.com/non/jawn)
      JSON library, and inherits a lot of it's performance from Erik's work.
</p>
  <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="VersionHistory" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Version History<a class=" scalatex-site-Styles-headerLink" href="#VersionHistory" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <h1 id="3.3.0" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#3.3.0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>3.3.0</h1>
      <ul>
        <li>
          Support for Scala-Native 0.5.0
</li></ul>
    <h1 id="3.2.0" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#3.2.0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>3.2.0</h1>
      <ul>
        <li>
          Add the <code>sortKeys = true</code> flag that can be passed to <code>upickle.default.write</code>
          or <code>ujson.write</code>, allowing you to ensure the generated JSON has object keys in sorted
          order
</li></ul>
    <h1 id="3.1.4" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#3.1.4" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>3.1.4</h1>
      <ul>
        <li>
          Add ability to set <code>allowUnknownKeys</code> to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">false</code> globally or on a per-case-class
          basis to raise errors if unknown keys are present <a href="https://github.com/com-lihaoyi/upickle/pull/548">#548</a></li>
        <li>
          Fix an issue failing to detect case class constructor default values in Scala 3.x
          when the case class is generic <a href="https://github.com/com-lihaoyi/upickle/pull/547">#547</a>
</li></ul>
    <h1 id="3.1.3" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#3.1.3" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>3.1.3</h1>
      <ul>
        <li>
          Fix reading of numbers as strings, e.g.
          <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">upickle.default.read[Seq[String]](&quot;[12345678901234567890]&quot;) ==&gt; Seq(&quot;12345678901234567890&quot;)</code>,
          for scenarios where you want to read JSON numbers &quot;as is&quot;, preserving the
          exact string representation, without rounding, truncation, or overflow.</li></ul>
    <h1 id="3.1.2" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#3.1.2" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>3.1.2</h1>
      <ul>
        <li>
          Fix parsing of large integers into <code>ujson.Num</code>s
          <a href="https://github.com/com-lihaoyi/upickle/pull/504">#504</a></li></ul>
    <h1 id="3.1.1" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#3.1.1" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>3.1.1</h1>
      <ul>
        <li>
          Bumped Scala versions: 3.3.0, <a href="https://github.com/com-lihaoyi/upickle/pull/492">#492</a>,
          2.13.11 <a href="https://github.com/com-lihaoyi/upickle/pull/497">#497</a>,
          2.12.18 <a href="https://github.com/com-lihaoyi/upickle/pull/492">#496</a>,</li>
        <li>
          Make empty arrays and dictionaries render compactly even when indent &gt; 0
          <a href="https://github.com/com-lihaoyi/upickle/pull/501">#501</a>,</li>
        <li>
          Improve <code>expected tagged dictionary</code> error message and make it work for
          non-empty dicts <a href="https://github.com/com-lihaoyi/upickle/pull/502">#502</a>,
</li></ul>
    <h1 id="3.1.0" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#3.1.0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>3.1.0</h1>
      <ul>
        <li>
          Across-the-board performance optimizations <a href="https://github.com/com-lihaoyi/upickle/pull/467">#467</a></li>
        <li>
          Make <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">derives</code> properly handle <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">abstract class</code>es in Scala 3
          <a href="https://github.com/com-lihaoyi/upickle/pull/470">#470</a></li>
        <li>
          Use a NotGiven implicit to avoid infinite loops caused by
          <code>superTypeWriter</code>/<code>superTypeReader</code>
          <a href="https://github.com/com-lihaoyi/upickle/pull/471">#471</a></li>
        <li>
          Fix ClassCastException on <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import given</code>
          <a href="https://github.com/com-lihaoyi/upickle/pull/472">#472</a></li>
        <li>
          Added readwriters for <code>SortedMap</code> and <code>LinkedHashMap</code>
          <a href="https://github.com/com-lihaoyi/upickle/pull/479">#479</a></li></ul>
    <h1 id="3.0.0" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#3.0.0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>3.0.0</h1>
      <ul>
        <li>
          Greatly improved speed and runtime-time safety for Scala 3 macros.
          These were previously much slower than Scala 2, and are now of roughly
          identical performance <a href="https://github.com/com-lihaoyi/upickle/pull/445">#445</a>
</li>
        <li>
          Fixed infinite compile-loop issue on Scala 3
</li>
        <li>
          Support for the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">deriving</code> keyword in Scala 3, on both <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">enum</code>s
          and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">sealed trait</code>s <a href="https://github.com/com-lihaoyi/upickle/pull/453">#453</a>
</li>
        <li>
          Ensured, that <code>ujson.Value</code>s behave properly as a direct target of reading
          and writing operations <a href="https://github.com/com-lihaoyi/upickle/pull/436">#436</a>
</li>
        <li>
          <b>Updated geny dependency from 0.7.1 to 1.0.0. This breaks binary compatibility, hence we increased the major version number.</b>
</li>
        <li>
          uPickle now applies Semantic Versioning and follows the SemVer spec
</li>
        <li>
          <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">ujson.Bool</code> pattern matching is now exhaustive
          <a href="https://github.com/com-lihaoyi/upickle/pull/461">#461</a>
</li>
        <li>
          Various library dependency updates
</li>
        <li>
          Added readers and writers for the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">java.lang</code> boxed versions
          of primitive types <a href="https://github.com/com-lihaoyi/upickle/pull/462">#462</a>
</li>
        <li>
          Always use UTF-8 when reading JSON bytes regardless of JVM default charset
          <a href="https://github.com/com-lihaoyi/upickle/pull/464">#464</a>
</li></ul>
    <h1 id="2.0.0" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#2.0.0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>2.0.0</h1>
      <ul>
        <li>
          <b>2.0.0 is a major breaking change in uPickle, including in the serialization
          format for many common data types (<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Map</code>s, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">case object</code>s,
          <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Unit</code>, etc.). Please be careful upgrading and follow the instructions
          below.</b>
</li>
        <li>
          If you are upgrading a system with multiple components from an earlier version
          of uPickle, please ensure you first upgrade every component to uPickle 1.6.0,
          which is forwards-compatible with the changes in uPickle 2.0.0. Only when every
          component is upgraded to 1.6.0 should you begin upgrading components to 2.0.0
</li>
        <li>
          Once every component is upgraded to 1.6.0, they will be able to <i>read</i> both
          the old and new serialization formats, though they will
          still be <i>writing</i> the old format. You can then
          upgrade your components piecemeal to 2.0.0 without any incompatibility.
</li>
        <li>
          uPickle 2.0.0 will <i>write</i> using the new serialization formats, but
          will be able to <i>read</i> both old and new formats indefinitely. Thus if you have
          data in storage using the old format, you do not need to migrate it to the new
          format, and it can remain as-is until it needs to be re-written for other reasons.
</li>
        <li>
          <b>Major serialization changes are below</b>
</li>
        <li>
          <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">case object</code>s are now serialized as literal strings
          <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;foo.bar.Qux&quot;</code> rather than JSON dictionaries
          <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">{&quot;$type&quot;: &quot;foo.bar.Qux&quot;}</code>
          <a href="https://github.com/com-lihaoyi/upickle/pull/382">#382</a>. This also
          applies to Scala 3 Enums <a href="https://github.com/com-lihaoyi/upickle/pull/378">378</a>
</li>
        <li>
          <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Map</code>s with primitive keys can now be serialized
          as JSON dictionaries <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">{&quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: &quot;qux&quot;}</code>, rather than
          as nested tuples <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">[[&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, &quot;qux&quot;]]</code>
          <a href="https://github.com/com-lihaoyi/upickle/pull/381">#381</a>. This applies
          to numbers, booleans, strings, <code>java.util.UUID</code>s, <code>BigIntegers</code>, <code>BigDecimals</code>,
          <code>scala.Symbol</code>s, <code>scala.concurrent.Duration</code>, and can be enabled for
          user-defined types. See <a href="#JSONDictionaryFormats">JSON Dictionary Formats</a> for more information</li>
        <li>
          <code>scala.Unit</code> now serializes as <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">null</code> rather than <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">{}</code>

</li></ul>
    <h1 id="1.6.0" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#1.6.0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>1.6.0</h1>
      <ul>
        <li>
          Forwards compatibility for uPickle 2.x (<a href="https://github.com/com-lihaoyi/upickle/pull/385">#385</a>).
          This reduces the strictness of deserialization logic to allow parsing of both old and new
          formats: <code>Map</code>s can be deserialized from both JSON list-of-list and JSON dictionary
          formats, numbers can be deserialized from strings, and <code>Unit</code> can be deserialized from
          empty JSON dictionaries or nulls</li>
        <li>
          Automatic serialization of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">case object</code>s has been removed, due to
          confusing bugs in how its implicit macro interacted with other implicit definitions.
          You now need to define <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">case object</code> serializers manually, via
          <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">implicit val rw: RW[MyCaseObject.type] = macroRW</code>
</li></ul>
    <h1 id="1.5.0" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#1.5.0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>1.5.0</h1>
      <ul>
        <li>
          Support Scala-Native on Scala 3
</li></ul>
    <h1 id="1.4.3" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#1.4.3" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>1.4.3</h1>
      <ul></ul> 
         <li>
           <code>MsgPackReader</code>: properly increment index in ext <a href="https://github.com/com-lihaoyi/upickle/pull/370">#370</a>
</li>
    <h1 id="1.4.2" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#1.4.2" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>1.4.2</h1>
      <ul>
         <li>
           Bugfixes <a href="https://github.com/com-lihaoyi/upickle/pull/365">#365</a> <a href="https://github.com/com-lihaoyi/upickle/pull/365">#366</a></li></ul>
    <h1 id="1.4.1" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#1.4.1" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>1.4.1</h1>
      <ul>
        <li>
          BugFix: Util.parseLong (<a href="https://github.com/lihaoyi/upickle/pull/361">#361</a>)</li>
        <li>
          Implement visitFloat32, visitFloat64String for Byte/Short/Int/Long/Float/Double/Char (<a href="https://github.com/lihaoyi/upickle/pull/358">#358</a>)</li></ul>
    <h1 id="1.4.0" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#1.4.0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>1.4.0</h1>
      <ul>
        <li>
          Added support for large case classes with &gt;64 fields</li></ul>
    <h1 id="1.3.11" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#1.3.11" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>1.3.11</h1>
      <ul>
        <li>
          Publish for Scala 3.0.0-RC2</li></ul>
    <h1 id="1.3.8" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#1.3.8" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>1.3.8</h1>
      <ul>
        <li>
          Minor performance tweaks</li></ul>
    <h1 id="1.3.7" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#1.3.7" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>1.3.7</h1>
      <ul>
        <li>
          Removed <code>ArrayIndexOutOfBound</code>s from parsing and replaced them with <code>ParsingFailedException</code>s</li></ul>
    <h1 id="1.3.0" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#1.3.0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>1.3.0</h1>
      <ul>
        <li>
          Significant improvements (30-50%) to performance of reading and writing
          large JSON files, especially working with binary data in byte arrays or
          input streams.</li></ul>
    <h1 id="1.2.0" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#1.2.0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>1.2.0</h1>
      <ul>
        <li>
          Add optional `trace = true` parameter to `ujson.read`, `upack.read`,
          `upickle.default.read` and `upickle.default.readBinary` to provide better error
          messages when parsing or deserialization fails</li></ul>
    <h1 id="0.9.6" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.9.6" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.9.6</h1>
      <ul>
        <li>
          Bump Geny dependency</li>
        <li>
          Add ability to parse from any <a href="https://github.com/lihaoyi/geny#readable">geny.Readable</a> data type, such as <code>java.io.InputStream</code></li></ul>
    <h1 id="0.9.0" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.9.0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.9.0</h1>
      <ul>
        <li>
          Basic support for GADTs <a href="https://github.com/lihaoyi/upickle/pull/288">#288</a></li>
        <li>
          <code>ujson.Value</code> and <code>upack.Msg</code> now support the
          <a href="https://github.com/lihaoyi/geny#writable">geny.Writable</a> interface</li>
        <li>
          Added new <code>upickle.default.writable</code> and <code>upickle.default.writableBinary</code>,
          to serialize Scala data types via the
          <a href="https://github.com/lihaoyi/geny#writable">geny.Writable</a> interface
</li></ul>
    <h1 id="0.8.0" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.8.0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.8.0</h1>
      <ul>
        <li>
          Improved performance by avoiding allocations in deserialization hot paths
          <a href="https://github.com/lihaoyi/upickle/pull/284">#284</a></li>
        <li>
          Add null-safe cast helpers <a href="https://github.com/lihaoyi/upickle/pull/274">#274</a></li></ul>
    <h1 id="0.7.5" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.7.5" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.7.5</h1>
      <ul>
        <li>
          Support for Scala 2.13.0 final</li></ul>
    <h1 id="0.7.1" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.7.1" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.7.1</h1>
      <ul>
        <li>
          Introduced new MessagePack backend for binary serialization! This is used
          via <code>upickle.default.writeBinary</code>/<code>upickle.default.readBinary</code>,
          or via the standalone <code>upack.read</code>/<code>upack.write</code> package.
          Binary serialization typically is 50-100% faster than JSON when running
          on the JVM.
</li>
        <li>
          <code>ujson.Js.Value</code>, <code>ujson.Js.Obj</code>, etc. are now just
          <code>ujson.Value</code>, <code>ujson.Obj</code>
</li>
        <li>
          Small <code>Long</code> 64-bit integers are now read/written as JSON numbers
          by default; only large values which cannot be precisely stored in
          <code>Double</code>-precision floating point (n &gt; 2^53) are written as strings.
          You can revert to the old behavior via a <a href="#CustomConfiguration">Custom Configuration</a>
          with:
          <pre><code class="scala scalatex-site-Styles-highlightMe">override implicit val LongWriter = new Writer[Long] {
  def write0[V](out: Visitor[_, V], v: Long) = out.visitInt64(v, -1)
}
</code></pre></li>
        <li>
          <code>upickle.json.*</code> and <code>upickle.Js.*</code> have been removed (use
          <code>ujson.*</code>.
</li></ul>
    <h1 id="0.6.7" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.6.7" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.6.7</h1>
      <ul>
        <li>
          Added the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">escapeUnicode: Boolean = false</code> flag to <code>ujson.Js#Render</code>
          and <code>ujson.Renderer</code>; pass in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">false</code> to rrender unicode
          characters verbatim rather than escaping them.</li></ul>
    <h1 id="0.6.6" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.6.6" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.6.6</h1>
      <ul>
        <li>
          Fix ability to construct single-element <code>Js.Obj</code> values without
          explicitly wrapping values [#230](https://github.com/lihaoyi/upickle/issues/230)</li>
        <li>
          Add <code>JsValue#bool</code> helper [#227](https://github.com/lihaoyi/upickle/pull/223)
          for extracting boolean values</li></ul>
    <h1 id="0.6.5" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.6.5" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.6.5</h1>
      <ul>
        <li>
          Add ability to update a JSON dictionary key or array item in place
          via <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">json(0)(&quot;myFieldA&quot;) = _.num + 100</code></li></ul>
    <h1 id="0.6.4" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.6.4" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.6.4</h1>
      <ul>
        <li>
          Fix uJson direct dependency artifact naming</li></ul>
    <h1 id="0.6.3" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.6.3" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.6.3</h1>
      <ul>
        <li>
          Added <code>ujson.copy</code> helper</li>
        <li>
          Added implicit constructors for <code>ujson.Js.Obj</code> and <code>Arr</code></li></ul>
    <h1 id="0.6.2" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.6.2" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.6.2</h1>
      <ul>
        <li>
          Fix conversion of case classes to other case classes via upickle.default.transform</li></ul>
    <h1 id="0.6.0" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.6.0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.6.0</h1>
      <ul>
        <li>
          ~3x faster than 0.5.1; uPickle now has the best <a href="#Performance">Performance</a>
          out of any of the commonly-used Scala JSON libraries
</li>
        <li>
          The old <code>upickle.Js</code> JSON AST and <a href="https://github.com/non/jawn">non/jawn</a>
          dependency have been combined into the <a href="#uJson">uJson</a> standalone library.
          uJson provides high-performance streaming JSON processing that lets uPickle
          parse input strings directly to case classes without an intermediate AST.</li>
        <li>
          <code>upickle.Js</code> objects are now mutable, and had some implicits added
          to make <a href="#Construction">Construction</a> less awkward.</li>
        <li>
          The set of <a href="#CommonOperations">Common Operations</a> and <a href="#JSONUtilities">JSON Utilities</a>
          has been fleshed out: you now have convenient helpers for streaming
          JSON re-formatting or validation, and can read from arbitrary inputs
          (strings, byte-arrays, files, ...) using the same <code>upickle.default.read</code>
          call</li>
        <li>
          The way you write <a href="#CustomPicklers">Custom Picklers</a> and <a href="#CustomConfiguration">Custom Configuration</a>
          has changed. The new ways are hopefully more intuitive,
          allow much better back-end performance, and should be just as flexible
          as the old way, but if you have custom picklers/configurations in your
          code you'll have to go update them.</li>
        <li>
          uPickle now supports parsing to (and serializing) <a href="#OtherASTs">Other ASTs</a>,
          from libraries such as Circe, Argonaut, Json4s or Play-Json. You can now
          also do high-performance/streaming <a href="#Cross-LibraryConversions">Cross-Library Conversions</a>
          to transform from one library's AST to another without any intermediate
          structures.
</li></ul>
    <h1 id="0.5.1" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.5.1" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.5.1</h1>
      <ul>
        <li>
          Strip out automatic &quot;deep&quot; case-class serialization: you must now
          define a serializer for each case class you want to deal with, preferably
          in the companion object</li>
        <li>
          Upgrade Jawn version to 0.11.0, add helpers in <code>ujson</code> to
          parse JSON coming from files.</li>
        <li>
          New <code>ujson.writeTo</code> function for serializing JSON directly
          to a <code>java.io.Writer</code>, rather than creating a <code>String</code>
</li>
        <li>
          <code>ujson.write</code> now takes an optional `sortKeys` flag, if
          you want the JSON dictionaries to rendered in a standardized order
</li>
        <li>
          Drop support fo Scala 2.10
</li></ul>
    <h1 id="0.4.3" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.4.3" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.4.3</h1>
      <ul>
        <li>
          Support for <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">BigInt</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">BigDecimal</code>,
          thanks to <a href="https://github.com/guersam">Jisoo Park</a></li>
        <li>
          <code>Js.Value</code>s are now serializable, thanks to
          <a href="https://github.com/fdietze">Felix Dietze</a></li>
        <li>
          Made it easy to write <a href="#ManualSealedTraitPicklers">Manual Sealed Trait Picklers</a>
          in order to work around problems with SI-7046</li></ul>
    <h1 id="0.4.1" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.4.1" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.4.1</h1>
      <ul>
        <li>
          Changes to <a href="http://www.lihaoyi.com/upickle-pprint/pprint/#0.4.2">PPrint</a></li></ul>
    <h1 id="0.4.1" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.4.1" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.4.1</h1>
      <ul>
        <li>
          Changes to <a href="http://www.lihaoyi.com/upickle-pprint/pprint/#0.4.1">PPrint</a></li></ul>
    <h1 id="0.4.0" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.4.0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.4.0</h1>
      <ul>
        <li>
          Allow custom handling for JSON <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">null</code>s via a <a href="#CustomConfiguration">Custom Configuration</a></li>
        <li>
          Made <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">upickle.key</code> a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">case class</code></li>
        <li>
          Remove unnecessary dependency of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">derive</code> on default arguments #143</li>
        <li>
          Fixed derivation allowing Caching Picklers in a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">case class</code>'s companion object, potentially speeding up compilation times and runtimes</li></ul>
    <h1 id="0.3.9" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.3.9" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.3.9</h1>
      <ul>
        <li>
          Add <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.arr: Seq[Js.Value]</code>, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.obj: Map[String, Js.Value]</code>, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.str: String</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.num: Double</code> helper methods on <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Js.Value</code> to simplify usage as a simple JSON tree.</li>
        <li>
          <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Invalid.Json</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Invalid.Data</code> now have better exception messages by default, which should simplify debugging</li>
        <li>
          Some usages should compile faster due to fiddling with implicits (#138)</li></ul>
    <h1 id="0.3.8" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.3.8" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.3.8</h1>
      <ul>
        <li>
          Tweaks to PPrint</li></ul>
    <h1 id="0.3.7" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.3.7" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.3.7</h1>
      <ul>
        <li>
          You can now pass in an <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">indent</code> parameter to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">upickle.default.write</code> in order to format/indent the JSON nicely across multiple lines</li>
        <li>
          Derivation based on sealed abstract classes works, in addition to traits (#104), thanks to <a href="https://github.com/Voltir">Voltir</a></li>
        <li>
          Fix non-deterministic failure due to improperly implemented <code>equals</code>/<code>hashCode</code> in macro (#124), thanks to <a href="https://github.com/lihaoyi/upickle-pprint/issues/124">Voltir</a></li>
        <li>
          Slightly improve hygiene of uPickle/PPrint macro expansion</li>
        <li>
          uPickle de-serialization failures should no longer throw <code>MatchErrors</code> (#101)</li>
        <li>
          Using case-class-derived <code>Reader</code>s/<code>Writer</code>s should no longer fail in class <code>extends</code> clauses (#108)</li>
        <li>
          <code>Float.NaN</code> and <code>Double.NaN</code> are now properly handled (#123)</li>
        <li>
          Provided an example of a <a href="#CustomConfiguration">Custom Configuration</a> being used to <code>snake_case</code> case-class fields during serialization/de-serialization (#120)
</li></ul>
    <h1 id="0.3.6" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.3.6" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.3.6</h1>
      <ul>
        <li>
          Fix more bugs in PPrint derivation</li></ul>
    <h1 id="0.3.5" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.3.5" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.3.5</h1>
      <ul>
        <li>
          Fix some bugs in PPrint derivation</li></ul>
    <h1 id="0.3.4" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.3.4" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.3.4</h1>
      <ul>
        <li>
          Remove unnecessary shapeless dependency</li></ul>
    <h1 id="0.3.3" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.3.3" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.3.3</h1>
      <ul>
        <li>
          Fix more edge cases to avoid diverging implicits</li></ul>
    <h1 id="0.3.2" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.3.2" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.3.2</h1>
      <ul>
        <li>
          Fix more edge cases around typeclass derivation: #94, #95, #96</li>
        <li>
          Don't get tripped up by custom Apply methods: #48</li></ul>
    <h1 id="0.3.1" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.3.1" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.3.1</h1>
      <ul>
        <li>
          Fixed edge cases around typeclass derivation
</li></ul>
    <h1 id="0.3.0" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.3.0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.3.0</h1>
      <ul>
        <li>
          Top-to-bottom rewrite of type-class derivation macros. Much faster, more reliable, etc.. Still one or two cases where it misbehaves, but much fewer than before. Extracted it into the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">derive</code> subproject</li>
        <li>
          Force users to choose between <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import upickle.default._</code> which now renders sealed trait hierarchies as dictionaries with a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">$type</code> attribute, and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import upickle.legacy._</code> which does the old-style array-wrapper.</li>
        <li>
          You can also now create your own custom subclass of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">upickle.Api</code> if you wish to customize things further, e.g. changing the type-attribute or changing the rendering of case classes.
</li></ul>
    <h1 id="0.2.8" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.2.8" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.2.8</h1>
      <ul>
        <li>
          Support for <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">java.util.UUID</code>, which are serialized as strings in the standard format
</li></ul>
    <h1 id="0.2.7" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.2.7" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.2.7</h1>
      <ul>
        <li>
          Re-published for Scala.js 0.6.1
</li></ul>
    <h1 id="0.2.6" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.2.6" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.2.6</h1>
      <ul>
        <li>
          <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">'Symbol</code>s are now read/write-able by default</li>
        <li>
          Added lots of warnings for common issues</li>
        <li>
          <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Map[String, V]</code> now pickles to a JSON dictionary <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;key&quot;: &quot;value&quot;, ...}</code>. <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Map[K, V]</code> for all other <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">K != String</code> are unchanged</li>
        <li>
          Source maps now point towards a reasonabel place on Github

</li></ul>
    <h1 id="0.2.5" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.2.5" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.2.5</h1>
      <ul>
        <li>
          Fixed [#23](https://github.com/lihaoyi/upickle/issues/23): self-recursive data structures are now supported.</li>
        <li>
          Fixed [#18](https://github.com/lihaoyi/upickle/issues/18): you can now auto-pickle classes in objects that originated from traits that were mixed in.

</li></ul>
    <h1 id="0.2.4" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.2.4" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.2.4</h1>
      <ul>
        <li>
          Support reading and writing <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">null</code></li>
        <li>
          Fixed Reader/Writer macros for single-class sealed hierarchies</li>
        <li>
          Used <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CanBuildFrom</code> to serialize a broader range of collections
</li></ul>
    <h1 id="0.2.3" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.2.3" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.2.3</h1>
      <ul>
        <li>
          Added a pickler for <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Unit</code>/<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">()</code>
</li></ul>
    <h1 id="0.2.2" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.2.2" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.2.2</h1>
      <ul>
        <li>
          Swapped over from the hand-rolled parser to using <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Jawn</code>/<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">JSON.parse</code> on the two platforms, resulting in a 10-15x speedup for JSON handling.</li>
        <li>
          Renamed <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Js.{String, Object, Array, Number}</code> into <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Js.{Str, Obj, Arr, Num}</code>, and made <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Js.Arr</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Js.Obj</code> use varargs, to allow for better direct-use.</li>
        <li>
          Documented and exposed JSON API for direct use by users of the library.
</li></ul>
    <h1 id="0.2.1" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.2.1" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.2.1</h1>
      <ul>
        <li>
          Improved error messages for unpickle-able types</li>
        <li>
          ScalaJS version now built against 0.5.3
</li></ul>
    <h1 id="0.2.0" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.2.0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.2.0</h1>
      <ul>
        <li>
          Members of sealed trait/class hierarchies are now keyed with the fully-qualified name of their class, rather than an index, as it is less likely to change due to adding or removing classes</li>
        <li>
          Members of sealed hierarchies and parameters now support a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">upickle.key(&quot;...&quot;)</code> annotation, which allows you to override the default key used (which is the class/parameter name) with a custom one, allowing you to change the class/param name in your code while maintaining compatibility with serialized structures</li>
        <li>
          Default parameters are now supported: they are used to substitute missing keys when reading, and cause the key/value pair to be omitted if the serialized value matches the default when writing</li>
        <li>
          Missing keys when deserializing case classes now throws a proper <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Invalid.Data</code> exception</li>
        <li>
          <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">object</code>s are now serialized as <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">{}</code> rather than <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">[]</code>, better matching the style of case classes</li>
        <li>
          0-argument case classes, previously unsupported, now serialize to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">{}</code> the same way as <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">object</code>s</li>
        <li>
          Fixed a bug that was preventing multi-level sealed class hierarchies from being serialized due to a compilation error</li>
        <li>
         Fixed a bug causing case classes nested in other packages/objects and referred to by their qualified paths to fail pickling</li>
        <li>
          Tightened up error handling semantics, swapping out several <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">MatchError</code>s with <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Invalid.Data</code> errors
</li></ul>
    <h1 id="0.1.7" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.1.7" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.1.7</h1>
      <ul>
        <li>
          Cleaned up the external API, marking lots of things which should have been private private or stuffing them in the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Internals</code> namespace</li>
        <li>
          Organized things such that only a single import <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import upickle._</code> is necessary to use the library
</li></ul>
    <h1 id="0.1.6" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.1.6" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.1.6</h1>
      <ul>
        <li>
          Tuples and case classes now have implicit picklers up to an arity limit of 22.</li>
        <li>
          Case classes now serialize as JSON dictionaries rather than as lists.
</li></ul>
    <h1 id="0.1.5" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.1.5" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.1.5</h1>
      <ul>
        <li>
          Simple case classes and case class hierarchies are now auto-serializable view Macros. No need to define your own implicit using <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Case0ReadWriter</code> anymore!
</li></ul>
    <h1 id="0.1.4" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.1.4" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.1.4</h1>
      <ul>
        <li>
          Serialize numbers as JSON numbers instead of Strings.
</li></ul>
    <h1 id="0.1.3" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.1.3" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.1.3</h1>
      <ul>
        <li>

          Specification of the exception-throwing behavior: instead of failing with random <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">MatchError</code>s or similar, parse failures now are restricted to subclasses <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">upickle.Invalid</code> which define different failure modes.</li></ul></div>
</div><script>
    scalatex.scrollspy.Controller().main(
      [{"value":"uPickle 3.3.0","children":[{"value":"Getting Started","children":[{"value":"ScalaJS","children":[]},{"value":"Scala Versions","children":[]}]},{"value":"Basics","children":[{"value":"Builtins","children":[{"value":"Primitives","children":[]},{"value":"Collections","children":[]},{"value":"Case Classes","children":[]},{"value":"Scala 3 Deriving","children":[]}]},{"value":"Read/Writing Other Things","children":[]},{"value":"Nulls","children":[]},{"value":"Defaults","children":[]},{"value":"Supported Types","children":[]},{"value":"Common Operations","children":[]}]},{"value":"Customization","children":[{"value":"Custom Picklers","children":[]},{"value":"Custom Keys","children":[]},{"value":"JSON Dictionary Formats","children":[]},{"value":"Custom Configuration","children":[]}]},{"value":"Limitations","children":[{"value":"Manual Sealed Trait Picklers","children":[]}]},{"value":"uJson","children":[{"value":"Construction","children":[]},{"value":"JSON Utilities","children":[]},{"value":"Transformations","children":[]},{"value":"Other ASTs","children":[{"value":"Argonaut","children":[]},{"value":"Circe","children":[]},{"value":"Play-Json","children":[]},{"value":"Json4s","children":[]},{"value":"Cross-Library Conversions","children":[]}]}]},{"value":"uPack","children":[]},{"value":"Performance","children":[{"value":"JVM Case Class Serialization Performance","children":[]},{"value":"JS Case Class Serialization Performance","children":[]}]},{"value":"Version History","children":[{"value":"3.3.0","children":[]},{"value":"3.2.0","children":[]},{"value":"3.1.4","children":[]},{"value":"3.1.3","children":[]},{"value":"3.1.2","children":[]},{"value":"3.1.1","children":[]},{"value":"3.1.0","children":[]},{"value":"3.0.0","children":[]},{"value":"2.0.0","children":[]},{"value":"1.6.0","children":[]},{"value":"1.5.0","children":[]},{"value":"1.4.3","children":[]},{"value":"1.4.2","children":[]},{"value":"1.4.1","children":[]},{"value":"1.4.0","children":[]},{"value":"1.3.11","children":[]},{"value":"1.3.8","children":[]},{"value":"1.3.7","children":[]},{"value":"1.3.0","children":[]},{"value":"1.2.0","children":[]},{"value":"0.9.6","children":[]},{"value":"0.9.0","children":[]},{"value":"0.8.0","children":[]},{"value":"0.7.5","children":[]},{"value":"0.7.1","children":[]},{"value":"0.6.7","children":[]},{"value":"0.6.6","children":[]},{"value":"0.6.5","children":[]},{"value":"0.6.4","children":[]},{"value":"0.6.3","children":[]},{"value":"0.6.2","children":[]},{"value":"0.6.0","children":[]},{"value":"0.5.1","children":[]},{"value":"0.4.3","children":[]},{"value":"0.4.1","children":[]},{"value":"0.4.1","children":[]},{"value":"0.4.0","children":[]},{"value":"0.3.9","children":[]},{"value":"0.3.8","children":[]},{"value":"0.3.7","children":[]},{"value":"0.3.6","children":[]},{"value":"0.3.5","children":[]},{"value":"0.3.4","children":[]},{"value":"0.3.3","children":[]},{"value":"0.3.2","children":[]},{"value":"0.3.1","children":[]},{"value":"0.3.0","children":[]},{"value":"0.2.8","children":[]},{"value":"0.2.7","children":[]},{"value":"0.2.6","children":[]},{"value":"0.2.5","children":[]},{"value":"0.2.4","children":[]},{"value":"0.2.3","children":[]},{"value":"0.2.2","children":[]},{"value":"0.2.1","children":[]},{"value":"0.2.0","children":[]},{"value":"0.1.7","children":[]},{"value":"0.1.6","children":[]},{"value":"0.1.5","children":[]},{"value":"0.1.4","children":[]},{"value":"0.1.3","children":[]}]}]}]
  )</script><script>
    ['DOMContentLoaded', 'load'].forEach(function(ev){
      addEventListener(ev, function(){
        Array.prototype.forEach.call(
          document.getElementsByClassName('scalatex-site-Styles-highlightMe'),
          hljs.highlightBlock
        );
      })
    })
  </script></body></html>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     